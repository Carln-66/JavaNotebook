# JavaNotebook
**Carl的java笔记本**

## 1. Java语言概述
### Java三大特点
特点一：面向对象
+ 两个基本概念：类和对象
+ 三大特性：封装性，继承性，多态性

特点二：健壮性
+ 吸收了C/C++语言的特点但是去掉了其影响程序健壮性的部分（例如指针、内存申请与释放等），提供了一个相对安全的内存管理和访问机制

特点三：跨平台性
+ 通过Java语言编写的应用程序在不同的系统平台上都能够运行。

### Java的两种核心机制
+ Java虚拟机(Java Virtual Machine)
    + JVM是一个虚拟的计算机，具有指令集并使用不同的储存区域。负责执行指令，管理数据、内存、寄存器。
    + 对于不同的平台(Windows、Mac OS、Linux)有不同的虚拟机。
    + 只有当某平台提供了对应的虚拟机时，java程序才能够在此平台上运行。
    + java虚拟机机制屏蔽了底层运行平台的差别，真正实现了一次编译，到处运行
+ 垃圾回收机制(Garbage Collection)
    + 将不再运行的空间回收
    + 垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。
    + GC的基本原理：对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

**但是Java程序同样会出现内存泄漏和内存溢出问题！**

### JDK、JRE
JDK(Java Development Kit)
Java开发工具包
JDK是提供给Java开发人员使用的，其中也包含了JRE。
+ 其中的开发工具：编译工具(javac.exe)打包工具(jar.exe)等

JRE(Java Runtime Environment)
其中包含Java虚拟机(JVM)和Java程序所需要的核心类库等等。

### path环境变量
path环境变量：windows操作系统执行命令时索要搜寻的路径  
为什么要配置path环境变量：希望java的开发工具(javac.exe、java.exe)在任何的文件路径下都可以执行成功。

## 2. Java基本语法
### 1. 关键字(keyword)的定义和特点
+ 定义：被Java语言赋予了特殊含义，用作专门用途的字符串(单词)
+ 特点：关键字中所有的字母都为小**写**

### 2. 保留字  
现有Java版本尚未使用，但是以后版本可能会作为关键字使用。在自己命名一些标识符的时候要尽量避免使用这些保留字。
例如：goto、const

### 3. 标识符  
定义：凡是自己可以起名字的地方都叫做*标识符*。  
涉及到的结构：包名，**类名**，接口名，**变量名**，**方法名**，常量名  
标识符的命名规则：**必须遵守，否则会编译出错**
具体细则：
+ 由26个英文字母大小写，0-9，_或$组成
+ 数字不可以作为开头
+ 不可以使用关键字和保留字，但能包含关键字和保留字
+ Java中严格区分大小写。长度无限制。
+ 标识符不能包含空格。  
 
 标识符的命名规范：可以不遵守，不影响程序的编译和运行，但是要求遵守。  
 + 包名：多单词组成是所有字母都小写：xxxxyyyyzzzz
 + 类名、接口名：多单词组成时，所有的单词的首字母大写XxxxYyyyZzzz
 + 变量名、方法名： 多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写xxxYyyZzz
 + 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ  
 
 + 注意1：在起名字时，为了提高阅读性，要尽量有意义。"见名知意"
 + 注意2：Java采用Unicode字符集，因此标识符也可以用汉字声明，但是不建议使用。
 ### 4. 变量的分类
 #### 4.1 按数据类型分类
 ##### 基本数据类型(Primitive Type)
+ 数值型：数值型又分为整数类型(byte, short, int, long)和浮点型(float, double)
+ 字符型(char)
+ 布尔型(boolean)
 #### 引用数据类型(Reference Type)
 + 类(class)：其中包含字符串String 
 + 接口(Interface)
 + 数组([ ])
 
 详细说明：  
         1. 整型：  
         ① byte(1字节=8bit)\short(2字节)\int(4字节)\long(8字节)  
         ② byte范围：-128~127  
         ③. 声明long型变量，必须以"l"或"L"结尾  
         ④. 通常，定义整型变量时，使用int型。  
         2. 浮点型：float(4字节)\double(8字节)  
         ① 浮点型表示带小数点的数值  
         ② float表示数值的范围比long还大  
         ③ 定义float类型变量时，变量要以"f"或"F"结尾  
         ④ 通常，定义浮点型变量时，使用double型    
         ⑤ 浮点型的常量，默认类型为double    
         3. 字符型(1字符=2字节)  
         ① 定义char型变量，通常使用一堆''，内部只能写一个字符  
         ② 表示方式：1.声明一个字符。2.转义字符。3.直接使用Unicode值来表示字符型常量  
         4. 布尔型(boolean)  
         ① 只能取两个值之一：true、false  
         ② 常常在条件判断、循环结构中使用
         
 #### 4.2 按声明的位置分类
 ##### 成员变量
 其中包括不以static修饰的实例变量和以static修饰的类变量
 ##### 局部变量
 其中包括形参(方法，构造器中定义的变量)，方法局部变量(在方法内定义)和局部变量(在代码块中定义)
 
 #### 4.3 定义变量的格式
 数据类型 变量名 = 变量值  
  或  
 数据类型 变量名  
 变狼名 = 变量值  
 #### 4.4 变量定义中注意的点
 + 变量必须先声明，后使用
 + 变量都定义在其作用域内部。在作用域内，它是有效的。换句话说，除了作用域就失效了  
 + 同一个作用域内，不可以声明两个同名的变量
 #### 4.5 基本数据类型变量间运算规则
 ##### 4.5.1 涉及到的基本数据类型：除了boolean类型之外的其他七种。
 ##### 4.5.2 自动类型转换(只涉及7种基本数据类型)
 **结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。**  
 + byte-->char-->short-->int-->long-->float-->double  
 + 特别地，当byte、char、short三种类型的变量做运算时，结果为int型
##### 4.5.3 强制类型转换(只涉及7种基本数据类型)：自动类型提升运算的逆运算(不一定必须要容量小的数据类型转换为容量大的数据类型)，需要使用强转符( )，可能出现精度损失。
##### 4.5.4 String与8种基本数据类型之间的运算
+ String属于引用数据类型，翻译为字符串
+ 声明String变量时，使用一对一""
+ String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+
+ 运算的结果依然是String类型

"&"和"&&"的异同 
就是用上来讲，两个都是可以的   
&　不管前面的条件是否正确，后面都执行  
&&　前面条件正确时，才执行后面，不正确时，就不执行，就效率而言，这个更好  
开发中一般用"&&"
### 5. 流程控制
#### 5.1 if-else条件判断语句
+ else结构是可选的  
+ 针对于条件表达式  
    + 如果多个条件表达式之间是"互斥"关系(或者没有交集的关系)，那个判断和执行语句声明在上面还是下面无所谓。
    + 如果多个条件表达式之间由交集的关系，需要根据实际情况，考虑清楚应该将那个结构声明在上面。
    + 如果多个表达式之间有包含的关系，通常情况下，需要将范围小的生命在范围大的上面，否则范围小的就没有机会执行了。
+ if-else结构是可以互相嵌套的。
+ 如果if-else结构中的执行语句只有一行时，对应的一对{ }可以省略。
#### 5.2 switch-case选择结构
+ 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。  
调用完执行语句之后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止.
+ break，可以使用在switch-case结构中，表示一旦执行到此关键字，就会跳出switch-case结构。
+ switch结构中的表达式，只能是如下的6种数据类型之一：  
byte、short、char、int、枚举类型、String类型  
+ case之后只能声明变量。不能声明范围。
+ break关键字是可以选择的。
+ default：相当于if-else结构中的else  
default结构是可选的，而且位置是灵活的。
#####  如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。
#####  break在switch-case中是可选的
#### 5.3 循环结构
##### 5.3.1 循环结构的四要素
① 初始化条件  
② 循环条件  --->必须是boolean类型  
③ 循环体  
④ 迭代条件  
*通常情况下，循环都是因为条件②中循环条件返回false了*
##### 5.3.2 三种循环结构
a. for循环结构  
```
for(①; ②; ④){  
                ③  
            }  
```
执行过程：① - ② - ③ - ④ - ② - ③ - ④ - . . . - ②  
b. while循环结构
```
 ①  
 while(②){  
            ③;  
            ④;  
        }
```
*写while循环千万小心不要丢了迭代条件，一旦丢了可能会导致死循环*  
for和while循环总结：  
+ 开发中基本上都会从for、while循环中选择，实现循环结构
+ for和while循环是可以相互转换的
    + 区别：for循环和while循环的初始化条件部分的作用范围不同
+ 写程序时一定要避免出现死循环
    
*遍历数组，字符串一般可以用for；如果逻辑很复杂的话可以考虑用while*

c. do-while循环结构
```
①  
do {
        ③;  
        ④;  
    }   
while(②);  
```
执行过程：① - ③ - ④ - ② - ③ - ④ - . . . - ②  
*do-while循环至少会执行一次循环体  
开发中，使用for和while更多一些。较少使用do-while*

d. “无限循环”结构：while(true)或for(;;)
+ 如何结束一个循环结构
    + 方式一：当循环条件是false时
    + 方式二：在循环体中，执行break
    
e. 嵌套循环
+ 嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环
    + 内层循环：循环结构A
    + 外层循环：循环结构B
+ 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次
+ 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行的m*n次。
+ 外层循环控制行数，内层循环控制列数。
  
**衡量一个功能代码的优劣**
1. 正确性(代码功能是否正确)
2. 可读性(代码能不能够给其他程序员读懂)
3. 健壮性(考虑在多种情况下代码的可运行性)
4. 高效率与低存储：**时间复杂度**、空间复杂度(衡量算法好坏的标准)

|        |  使用范围  | 循环中使用的作用(不同点)   |  相同点 |  
|:----:|:-------------------:|:----------:|:---------------------:|  
|break|switch-case循环结构中|结束当前循环|关键字后面不能声明执行语句|  
|continue|循环结构中|结束当次循环|关键字后面不能声明执行语句|  

*带标签的break和continue的使用*  

## 3. 数组
### 3.1 数组的概述
#### 3.1.1 数组的理解
数组(Array)是多个**相同类型**数据按照一定顺序排列的集合，并使用一个名字命名，并且通过编号的方式对这些数据进行统一管理。
#### 3.1.2 数组的相关概念
+ 数组名
+ 元素
+ 角标、下标、索引
+ 数组的长度：元素的个数
#### 3.1.3 数组的特点
+ 数组是顺序排列的
+ 数组属于**引用数据类型**的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型
+ 创建数组对象会在内存中开辟一整块**连续**的空间
+ 数组的长度一旦确定，就不能修改
#### 3.1.4 数组的分类
+ 按照维数：一维数组、二维数组、...
+ 按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组  

*数据结构：*  
*1. 数据与数据之间的逻辑关系：集合、一对一(链表)、一对多(树形结构)、多对多(社交网络)*  
*2. 数据的储存结构：*  
*线性表：顺序表(比如数组)、链表、栈、队列*  
*树形结构：二叉树*  
*图形结构：*  
*算法：排序算法、搜索算法*  

### 3.2 一维数组
#### 3.2.1 一维数组的声明与初始化
```
    int num         //声明
    num = 10        //初始化
    int id = 1001;  //声明+初始化

    int[] ids;      //声明
    //1.1 静态初始化：数组的初始化和数组元素的赋值操作同时进行
    ids = new int[]{1, 2, 3, 4, 5};
    //1.2 动态初始化：数组的初始化和数组元素的赋值操作分开进行
    String[] names = new String[5];   
    
    int[] array4 = {1, 2, 3, 4, 5};     //类型推断
```
#### 3.2.1 一维数组元素的引用
通过角标的方式调用
````
    //数组的角标(或索引)从0开始，到数组的长度-1结束
    names[0] = "张三";
    names[1] = "李四";
    names[2] = "王五";
````

#### 3.2.3 数组的属性：length
通过数组名.length调用
+ 数组一旦初始化，其长度就是确定的
+ 数组长度一旦确定，就不可修改

#### 3.2.4 一维数组的遍历
````
    //通过for循环遍历数组
    for(int i = 0; i < array.length; i++){
        System.out.println(array[i]);
    }
````
#### 3.2.5 一维数组元素的默认初始化值
+ 整型--->0
+ 浮点型--->0.0
+ char型--->0或'\u0000'，而非'0'
+ boolean型--->false
+ 引用数据类型--->null
#### 3.2.6 一维数组的内存解析
![一维数组的内存解析](https://pic2.zhimg.com/v2-43094dabbbc6fb0757a3ae2b18eb5c39_r.jpg)
![一维数组的内存解析](https://pic2.zhimg.com/v2-7b7e7d43901dbab5c3e265b25b668b75_r.jpg)
![一维数组的内存解析](https://pic2.zhimg.com/v2-1e27dbf3b7175f33f7cfdfb6fb113421_r.jpg)
![一维数组的内存解析](https://pic4.zhimg.com/v2-7a9ca791801af19714437351a217eac3_r.jpg)
*图片引用自知乎用户@Dunn.c，侵删*

### 3.3 二维数组
#### 3.3.1 如何理解二维数组
数组属于引用数据类型，数组的元素也可以是引用数据类型。一个一维数组的元素如果还是一个一维数组类型，则此数组称为二维数组。
#### 3.3.2  二维数组的声明和初始化
````
    int[] array = new int[]{1, 2, 3}; //一维数组
    //静态初始化
    int[][] array1 = new int[][]{{1, 2, 3,},{4, 5}, {6, 7, 8}};
    //动态初始化1
    String[][] array2 = new String[3][2];
    //动态初始化2
    String[][] array3 = new String[3][];
    //下面同样是正确的，但是写法并不标准
    int[] array4[] = new int[][]{{1, 2, 3,},{4, 5}, {6, 7, 8}};
    int[] array5 = {{1, 2, 3,},{4, 5}, {6, 7, 8}};
````

#### 3.3.3 如何调用二维数组的元素
````
    System.out.println(array[0][1]);
    System.out.println(array[0]);
````
#### 3.3.4 二维数组的属性  
````
    System.out.println(array.length);       //array数组外层有几个元素
    System.out.println(array[0].length);    //array数组外层中第0个数组内有几个元素
````
#### 3.3.5 遍历二维数组
````
    //双层for循环遍历二维数组
    for(int i = 0; i < array.length; i++){
        for(int j = 0; j < array[i]; j++){
        System.out.println(array[i][j] + " ");
        }
    System.out.println();
    }
````
#### 3.3.6 二维数组元素的默认初始化值
规定：二维数组分为外层数组的元素和内层数组的元素  
> int[ ][ ] array = new int[4][3];  
外层元素：array[0], array[1]等  
>内层元素：array[0][1], array[1][2]等

数组元素的默认初始化值  
针对于初始化方式一：比如： int[ ][ ] = array = new int[4][3];  
外层元素的初始化值为：地址值  
内层元素的初始化值为：与一维数组初始化情况相同

针对于初始化方式二：比如：int[ ][ ] = array = new int[4][ ];  
外层元素的初始化值为：null  
内层元素的初始化值为：不能调用，否则报错

#### 3.3.7 二维数组的内存结构
![二维数组的内存结构](https://img-blog.csdnimg.cn/20200221165644893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzcxMDk2,size_16,color_FFFFFF,t_70)
*引用自CSDN用户@Kafka_Hive_Flink，侵删*

### 3.4 数组的常见算法
#### 3.4.1 数组的创建与元素赋值
杨辉三角(二维数组)、回型数(二维数组)
#### 3.4.2 针对于数值型的数组
最大值、最小值、总和、平均数等
#### 3.4.3 数组的赋值与复制
````
    int[] array1, array2;
    array1 = new int[]{1, 2, 3, 4};
    //赋值
    array2 = new array1 //将array1保存的数组地址值赋给了array2，使得数组array1和array2共同指向堆空间的中同一个数组实体。
    //复制
    array2 = new int(array1.length) //重新创建了一个数组实体
    for(int i = 0; i < array2.length; i++){ //将array1数组的所有元素值赋给array2的数组
        array2[i] = array1[i];
    }
````
#### 3.4.4 数组元素的反转
````
    //方法一
    for (int i = 0; i < array.length / 2; i++){
        String temp = array[i];
        array[i] = array[array.length - i - 1];
        array[array.length - i -1] = temp;
    }
````
````
    //方法二
    for (int i = 0; j = array.length - 1; i < j; i++, j--){
        String temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
````
#### 3.4.5 数组中指定元素的查找：搜索、检索
##### 3.4.5.1 线性查找
实现思路：通过遍历的方式，一个一个的数据进行比较、查找  
适用性：具有普遍适用性
##### 3.4.5.2 二分法查找
实现思路：每次比较中间值，折半的方式检索。  
实用性：需要数组必须有序
#### 3.4.6 数组的排序算法
十大排序算法
+ 选择排序
    + 直接选择排序、*堆排序*
+ 交换排序
    + **冒泡排序、快速排序**
+ 插入排序
    + 直接插入排序、折半插入排序、Shell排序
+ *归并排序*
+ 桶式排序
+ 基数排序

1.衡量排序算法的优劣的指标  
+ 时间复杂度
+ 空间复杂度
+ 稳定性  
2.排序的分类
+ 内部排序
+ 外部排序(需要借助于磁盘)  
3.不同排序算法的时间复杂度  
![不同排序算法的时间复杂度](https://images2015.cnblogs.com/blog/975503/201702/975503-20170214211234550-1109833343.png)
*引用自博客园用户@simple_wxl,侵删*
#### 3.4.7 冒泡排序
````
        int[] array = new int[]{43, 32, 76, -98, 0, 64, 33};
        //冒泡排序
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + "  ");
        }
````

### 3.5 Arrays工具类的使用
#### 3.5.1 理解
+ 定义在Arrays.util包下
+ Arrays提供了很多操作数组的方法
#### 3.5.2 基本的使用
+ boolean equals(int[] a, int[] b) 判断两个数组是否相等。
+ String toString(int[] a) 输出数组信息。
+ void fill(int[] a,int val) 将指定值填充到数组之中。
+ void sort(int[] a) 对数组进行排序。
+ int binarySearch(int[] a, int key) 对排序后的数组进行二分法检索指定的值。

### 3.6 数组的常见异常
数组脚标越界异常(ArrayIndexOutOfBoundsException)  
````
    int[] array = new int[2];  
    System.out.println(array[2]);  
    System.out.println(array[-1]);  
````
访问到了数组中的不存在的脚标时发生。
  
空指针异常(NullPointerException)  
````
    int[] array = null;
    System.out.println(array[0]);
````
array引用没有指向实体，却在操作实体中的元素时产生。

## 4. 面向对象--上
### 4.1 类与对象
#### 4.1.1 面向对象的三天条主线
1. Java类及类的成员：属性、方法、构造器、代码块、内部类
2. **面向对象的三大特征**：封装性、继承性、多态性
3. 其他关键字：this、super、static、final、abstract、interface、package、import
#### 4.1.2 面向对象与面向过程
1. 面向过程：强调的是功能行为，以函数为最小单位，考虑如何去做。
2. 面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑由谁来做。 
#### 4.1.3 完成一个项目(或功能)的思路
+ 根据问题需要，选择问题所针对的**现实世界中的实体**
+ 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了**概念世界中的类**
+ 把抽象的实体用计算机语言进行描述，**形成计算机世界中类的定义**。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构
+ 将**类实例化成计算机世界中的对象**。对象是计算机世界中解决问题的工具
#### 4.1.4 面向对象中两个重要的概念
类：对**一类事物**的描述。是抽象的，概念上的定义。  
对象： 是**实际存在的**该事物的每个**个体**，因而也成为**实例**(Instance)  
面向对象程序设计的重点是**类的设计**  
设计类，就是设计**类的成员**  

二者的关系：  
对象是在类中通过new操作创造出来的，或着说派生出来的。
#### 4.1.5 面向对象思想落地实现的原则
1. 创建类，设计类的成员
2. 创建类的对象
3. 通过"对象.属性"或"对象.方法"调用对象的结构来解决问题  
几个概念的使用说明  
*属性=成员变量=field=域、字段*  
*方法=成员方法=函数=method*  
*创建类的对象=类的实例化=实例化类*
#### 4.1.6 对象的窗机与对象的内存解析
典型代码
````
    Employee e1 = new Employee();
    Employee e2 = new Employee();
    Employee e3 = e1;   //此时，e3与e1指向同一个地址值，即没有创建一个新对象
````
说明：  
如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性(仅限于static)。  
意味着：如果我们修改一个对象的属性a，它不会影响另外一个对象属性a的值。  
#### 4.1.7 匿名对象
匿名对象：我们创建的对象，没显式的赋给一个变量名。即为匿名对象  
特点：匿名对象只能调用一次  
举例：
````
    new Phone().sendEmail();
    new Phone().playGame();

    new Phone().price = 1999;
    new Phone().showPrice();

    //开发中的应用
    public void show(Phone phone){
        phone.sendEmail();
        phone.playGame();
    }
````
#### 4.1.8 万事万物皆对象
在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构  
+ Scanner，String等  
+ 文件：file  
+ 网络资源：URL  

涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类和对象。

---
JVM内存结构  
编译完源程序之后，生成一个或多个字节码(class)文件。  
我们使用JVM终得蕾姐在其和解释器对生成的字节码文件进行解释运行。意味着需要将字节码对相应的类加载到内存中，涉及到内存解析。  
![内存解析](https://img-blog.csdnimg.cn/2019040912492050.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Jvbmd0YW91cA==,size_16,color_FFFFFF,t_70)  
*引用自CSDN用户@_Rt，侵删*  

虚拟机栈即为平时提到的栈结构。**我们将局部变量储存在栈结构中**  
堆，我们将new出来的结构(如数组、对象)加载在堆空间中。  
对象的属性(非static)加载在堆空间中。  
方法区：类的加载信息、常量池、静态域

---

### 4.2 类的结构之一：属性
#### 4.2.1 对比属性与局部变量  
1. 相同点：  
1.1 定义变量的格式：数据类型 变量名 = 变量值  
1.2 先声明，后使用  
1.3 变量都有其对应的作用域   
2. 不同点：  
2.1 在类中声明的位置不同
+ 属性：直接定义在一对{ }内
+ 局部变量： 声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量  
2.2 关于权限修饰符的不同
+ 属性：可以在声明属性时，指明其权限，使用权限修饰符
    + 常用的权限修饰符：private、public、缺省、protected --->这些权限修饰符体现了封装性
+ 局部变量不能够使用权限修饰符  
2.3 默认初始化值的情况
+ 属性：类的属性，根据其类型，都默认初始化值。
    + 整型(byte、short、int、long)：0
    + 浮点型(float、double)：0.0
    + 字符型(char)：0或'\u0000'
    + 布尔型(boolean)：false
    + 引用数据类型(类、数组、接口)：null
+ 局部变量：没有默认初始化值
    + 意味着我们在调用局部变量之前，一定要显式赋值。特别地：形参在调用时，我们赋值即可。  
2.4 在内存中加载的位置：  
+ 属性：加载到堆空间中(非static)
+ 局部变量：加载到栈空间
### 4.3 类的结构之二：方法
方法：描述类应该具有的功能  
比如：  
Math类：sqrt( ) \ random( ) \ ...  
Scanner类：nextXxx( ) ...
Arrays类：sort( ) \ binarySearch( ) \ toString( ) \ equals( )\ ...

#### 4.3.1 举例：
````
    pubic void eat();
    public void sleep(int hour){ }
    public String getName(){ }
    public String getNation(String nation){ }
````
#### 4.3.2 方法的声明
````
    权限修饰符 返回值类型 方法名(形参列表){
            方法体
    }
````  
#### 4.3.3 说明：
##### 4.3.3.1 关于权限修饰符
默认方法的权限修饰符先都使用public。Java规定的4种权限修饰符：private、public、缺省、protected。  
##### 4.3.3.2 返回值类型
有返回值与没有返回值
1. 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同事，方法中需要使用return关键字来返回指定类型的常量或者变量："return 数据"。  
如果方法没有返回值，则方法声明时用void表示。通常情况下，没有返回值的方法中就不需要使用return。但如果使用的话也不会报错，但是只能以"return;"表示结束此方法。
2. 该不该返回值
+ 凭经验
+ 题目要求
##### 4.3.3.3 方法名
属于标识符，遵循标识符的规则和规范，要有见名知意的作用。
##### 4.3.3.4 形参列表
方法可以声明0个，1个或多个形参。  
1. 格式：数据类型1 形参1，数据类型2 形参2，...
2. 定义方法时该不该定义形参
+ 题目要求
+ 凭经验
##### 4.3.3.5 方法体
方法体：方法功能的实现。  

return关键字  
1.使用范围：使用在方法体中  
2.作用：  
+ 结束方法
+ 针对于返回值类型的方法，使用"return 数据"方法返回所需要的数据  

3.注意的点：return关键字后面不可以声明执行语句。  

**注意的是，可以调用当前类的属性或方法。特殊地：方法A中又调用了方法A：递归方法。**  
**方法中，不可以定义方法**

#### 4.3.4 方法的重载
##### 4.3.4.1 方法的重载的概念
定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可。  
"两同以不同"：同一个类、相同方法名；参数列表不同：参数个数不同，参数类型不同
##### 4.3.4.2 构成重载的举例
Arrays类中重载的sort( ) / binarySearch( )； PrintStream中的println( )  
##### 4.3.4.3 如何判断构成方法的重载
严格按照定义判断：量同以不同(跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系)
##### 4.3.4.4 如何确定类中某一个方法的调用
方法名--->参数列表

#### 4.3.5 可变个数形参的方法
##### 4.3.5.1 使用说明
1. jdk 5.0新增的内容  
2. 具体使用：  
2.1 可变个数形参的格式：数据类型...变量名。  
2.2 当调用可变个数形参的方法时，传入的参数个数可以是0个，1个，2个...。  
2.3 可变个数形参的方法与本类中的方法名相同，形参不同的方法之间构成重载。  
2.4 可变个数形参的方法与本类中的方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。  
2.5 可变个数形参在方法的形参中，必须声明在末尾。  
2.6 可变个数形参在方法的形参中，最多只能声明一个可变形参。  
##### 4.3.5.2 举例
````
    public void show(String s){
        System.out.println("show(String)");
    }
    public vodi show(String ... strs){
        System.out.println("Show(String ... strs)");
        for (int i = 0; i < strs; i++){
            System.out.println(strs[i]);
        }
    }
    //以下方法不能遇上一个方法同时存在(不构成重载)
    public void show(String[] strs){
    
    }
````


#### 4.3.5 Java的值得传递机制
##### 4.3.5.1 方法内的变量的赋值
如果变量是基本数据类型，此时赋值的是变量所保存的数据值。  
如果变量是引用数据类型，此时赋值的是变量做保存的数据的地址值。  
##### 4.3.5.2 针对于方法的参数概念
形参：方法定义时，声明的小括号内的参数  
实参：方法调用时，事迹传递给形参的参数  
##### 4.3.5.3 Java中参数的传递机制：值传递
规则：  
+ 如果参数是基本数据类型，此时实参赋给形参的是实参真实储存的数据值  
+ 如果参数是引用数据类型，此时实参赋给形参的是实参储存数据的地址值  
推广：  
+ 如果变量是**基本数据类型**，此时赋值的是变量所保存的**数据值**
+ 如果变量是**引用数据类型**，此时赋值的是变量所保存的数据的**地址值**

#### 4.3.6 Java的传递机制
##### 4.3.6.1 定义
递归方法：一个方法体内调用它自身
##### 4.3.6.2 如何理解递归方法
+ 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无需循环控制
+ 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环
##### 4.3.6.3 举例
````
    //计算1-n之间所有自然数的和
    public int getSum(int n){
        if (n == 1){
            return 1;
        }else{
            return n + getSum(n - 1);
        }
    }
````

### 4.4 面向对象的特征之一：封装与隐藏
#### 4.4.1 为什么要引入封装性
设计程序追求的是"**高内聚，低耦合**"。  
高内聚：类的内部数据操作细节自己完成，不允许外部干涉  
低耦合： 仅对外暴露少量的方法用于使用  
+ 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，**把该隐藏的隐藏起来，该暴露的暴露出来，这就是封装性的设计思想**。
#### 4.4.2 问题的引入
当我们创建了一个类的对象之后，我们可以通过”对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和储存范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。(比如：setLegs( )同时，我们需要避免用户再次使用"对象.属性"的方式对属性进行赋值。则需要将属性声明为私有的(private))。  
此时，针对于属性就体现了封装性。
*需要说明的是，封装性不仅仅体现在上述一个方面*
#### 4.4.3 封装性思想具体的代码体现：
体现一：将类的属性xxx私有化(private)，同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值
体现二：不对外暴露的私有的方法
体现三：单例模式(将构造器私有化)
体现四：如果不希望类在包外被调用，可以将类设置为缺省的。
#### 4.4.4. Java规定的四种权限修饰符(可以考虑将其等价为封装性)
##### 4.4.4.1 权限从小到大的顺序
private < 缺省 < protected < public
##### 4.4.4.2 具体的修饰范围
|修饰符|类内部|同一个包|不同包的子类|同一个工程|  
|:----:|:----:|:----:|:----:|:----:|  
|private|Yes|No|No|No|  
|缺省|Yes|Yes|No|No|  
|protected|Yes|Yes|Yes|No|    
|public|Yes|Yes|Yes|Yes|
##### 4.4.4.3 权限修饰符可以用来修饰的结构说明
4种权限修饰都可以用来修饰类的内部结构：属性、方法、构造器、内部类  
修饰类的权限修饰符只能使用缺省、public  

### 4.5 类的结构：构造器
#### 4.5.1 构造器(或构造方法)Constructor
##### 4.5.1.1 构造器的作用
+ 创建初始对象  
+ 初始化对象信息  
**只要造对象，就必须用到构造器**
##### 4.5.1.2 使用说明
+ 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器
+ 定义构造器的格式：权限修饰符 类名(形参列表){ }
+ 一个类中定义的多个构造器，彼此构成重载  
+ 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器
+ 一个类中，至少会有一个构造器  

#### 4.5.2 属性赋值顺序
a 默认初始化  
b 显式初始化  
c 构造器中初始化
---  
d 通过"对象.方法"或"对象.属性"的方式赋值  
以上操作的先后顺序：a - b - c - d  
#### 4.5.3 JavaBean
JavaBean的概念：所谓JavaBean，是指符合如下标准的Java类  
+ 类是公共的
+ 有一个**无参数**的公共的构造器
+ 属性，切对象的get，set方法  
### 4.6 关键字：this
#### 4.6.1 可以调用的结构
属性、方法; 构造器
#### 4.6.2 this调用属性、方法
this理解为：当前对象或当前正在创建的对象。  
1. **在类的方法中**，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是在通常情况下，我们都选择省略"this"。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。
2. **在类的构造器中**，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。但是通常情况下，我们都选择省略"this"。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。
#### 4.6.3
+ 我们在类的构造器中，可以显示的使用"this(形参列表)"方式，调用本类中指定的其它构造器
+ 构造其中不能通过"this(形参列表)"方式调用自己
+ 如果一个类中有n个构造器，则最多有n - 1个构造器使用了"this(形参列表)"
+ 规定:"this(形参列表)"必须声明在当前构造器的首行
+ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器

### 4.7 关键字package/import
#### 4.7.1 package的使用
#### 4.7.1.1 使用说明：
+ 为了更好地实现项目中类的管理，提供包的概念  
+ 使用package声明类或接口所属的包，声明在源文件的首行  
+ 包属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)  
+ 每"."一次，就代表一层文件目录  
**同一个包下，不能命名同名的接口、类**  
**不同的包下，可以命名同名的接口、类**
##### 4.7.1.2 JDK中主要包介绍
+ java.lang----包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能
+ java.net----包含执行与网络相关的操作的类和接口。
+ java.io ----包含能提供多种输入/输出功能的类。
+ java.util----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。
+ java.text----包含了一些java格式化相关的类
+ java.sql----包含了java进行JDBC数据库编程的相关类/接口
+ java.awt----包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S
#### 4.7.2 import的使用
import：导入  
1. 在源文件中显式的使用import结构导入指定包下的类、接口  
2. 声明在包的声明和类的声明之间  
3. 如果需要导入多个结构，则并列写出即可  
4. 可以使用"xxx.*"的方式，表示可以导入xxx包下的所有结构  
5. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构  
6. 如果使用的类或接口是本包下定义的，则可以省略import结构  
7. 在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示  
8. 使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入  
9. import static：导入指定类或接口中的静态结构：属性或方法  

## 5. 面向对象--中
### 5.1 面向对象的特征二：继承性
#### 5.1.1 为什么要有类的继承性(继承性的优点)
+ 减少了代码的冗余，提高了代码的复用性
+ 便于功能的拓展
+ 为之后多态性的使用提供了前提
#### 5.1.2 继承性的格式
> class A extends B{ }

+ A：子类、派生类、subclass
+ B：父类、超类、基类、superclass
#### 5.1.3 子类继承父类以后会有哪些不同
1. 体现：一旦子类A继承父类B以后，子类A中就获取了B中声明的所有属性和方法。**特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只是因为封装性的影响，是的子类不能直接调用父类的结构而已**。   
2. 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系并不同于子集和集合的关系。
#### 5.1.4 Java继承中的说明
+ 一个类可以被多个子类继承
+ Java中类的单继承性：一个类只能有一个父类
+ 子父类是相对的概念
+ 子类直接继承的父类，称为直接父类；间接继承的父类称为间接父类
+ 子类继承父类以后，就获取了直接弗雷以及所有间接父类中声明的属性和方法
#### 5.1.5 java.lang.Object类的理解
+ 如果我们没显式的声明一个类的父类的话，则粗类继承与java.lang.Object类
+ 所有的java(除java.lang.Object类之外都直接或间接的继承于java.lang.Object类)
+ 意味着，所有的java类具有java.lang.Object类声明的功能

### 5.2 方法的重写
#### 5.2.1 什么是方法的重写(override或overwrite)
重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作(因为父类的方法可能不适用于子类了)
#### 5.2.2 应用
重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写的方法。
#### 5.2.3 举例
````
    class Circle{
        public double findArea(){}  //求面积
    }
    class Cylinder extends Cirecle{
        public double findArea(){}  //求表面积
    }   
````
#### 5.2.4 重写的规则
方法的声明：
````
权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{  
                    方法体  
                }  
````
约定俗成：子类中的叫重写的叫重写的方法；父类中的叫被重写的方法
+ 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
+ 子类重写的方法的权限修饰符不小于父类中被重写的方法的权限修饰符
    +特殊情况：子类不能重写父类中声明为private权限的方法
+ 返回值类型
    + 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
    + 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以使A类或A类的子类
    + 父类被重写的方法的返回值类型是基本数据类型(比如double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
    + 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型
    + 子类和父类的同名同参数的方法要么都声明为static的(考虑重写，要么就都声明为static的)  
    
区分方法的重写和重载？  
答：1. 二者的概念    
2. 重载和重写的具体规则  
3. 重载：不表现为多态性  
重写：表现为多态性  
重载，是指允许存在多个同名方法，而这些方法的参数不同。根据编译方法不同的参数列表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。**它们的调用地址在编译期就绑定了**。java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。  
所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为"**早绑定**"或"**静态绑定**"。  
而对于多台，直等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为"**晚绑定**"或"**动态绑定**"。
 
### 5.3 关键字super
#### 5.3.1 super关键字可以理解为
父类的
#### 5.3.2 可以用来雕用的结构
属性、方法、构造器
#### 5.3.3 super调用属性、方法
1. 我们可以在子类的方法或构造器中，通过"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super"。  
2. 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须是显式的使用"super.属性"的方式，表明调用的是父类中是声明的属性。  
3. 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类被重写的方法时，则必须是显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。  
#### 5.3.4 super调用构造器
+ 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
+ "super.(形参列表)"的使用必须声明在子类构造器的首行
+ 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
+ 在构造器的首行，没显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super( )
+ 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器

### 5.4 子类对象实例化全过程
从结果上看：继承性  
+ 子类继承父类以后，就获取了父类中声明的属性或方法
+ 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
从过程上来看：  
当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类结构，所以才可以看到内存中父类的结构，子类对象才可以考虑进行调用

### 5.5 面向对象的特征三：多态性
#### 5.5.1 多态性的理解
可以理解为一个事物的多种形态
#### 5.5.2 何为多态性
对象的多态性：父类的引用指向子类的对象(或子类的对象赋给父类的引用)
> Employee e = new Manager();  
> Object obj = new Date();
#### 5.5.3 多态性的使用
多态性的使用：虚拟方法调用  
有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但是在运行期，我们实际执行的是子类重写父类的方法。  
总结： 编译看左边，运行看右边。
#### 5.5.4 多态性的使用前提
+ 类的继承关系
+ 方法的重写
#### 5.5.5 多态性的应用举例
```` 
    //举例一
    public void func(Animal animal){    //Animal animal = new Dog();
        animal.eat();
        animal.shout();
````
````
    //举例二
    public boid method(Object obj){

    } 
````
#### 5.5.6 多态性使用的注意点
对象的多态性，只适用于方法，不适用于属性(编译和运行都看左边)

#### 5.6.7 关于向上转型和向下转型
1. 向上转型：多态
2. 向下转型  
2.1 为什么使用向下转型：有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时只能调用父类声明的属性和方法。子类特有的属性和方法不能调用。  
如何才能调用子类特有的属性和方法：使用向下转型。  
2.2 如何实现向下转型  
使用强制类型转换符：( )  
2.3 使用时注意的点  
使用强制类型转换时，可能出现ClassCastException的异常。为了避免在向下转型时出现此异常，我们在向下转型之前，先进行instanceof判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。  
2.4 instanceof的使用  
a instanceof A：判断对象a是否是对象A的实例。如果是，返回true；如果不是，返回false。  
如果a instanceof A返回true，则a instanceof B也返回true。其中类B是类A的父类。  
要求a所属的类与类A必须是子类和父类的关系，否则编译错误。  

----
对多态性的理解：  
 + 实现代码的通用性
 + Object类中定义的public boolean equals(Object obj){ }  
 JDBC：使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)
 + 抽象类和接口的使用，如果没有多态性，这两部分就没有意义。(抽象类、接口不能实例化)

多态是编译时行为还是运行时行为？
运行时行为
````
    public static void main(String[] args){
        int key = new Random().nextInt(3);
        System.out.println(key);
        Animal animal = getInstance(key);
        animal.eat();
    }
````
 
### 5.6 Object类的使用
#### 5.6.1 java.lang.Object类的说明
+ Object类是所有java类的根父类
+ 如果在类的生命中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
+ Object类中的功能(属性、方法)具有通用性
    + 属性：无
    + 方法：equals() / toString() / getClass() / hashCode() / clone() / finalize() / wait() / notify()、notifyAll()
+ Object类只声明了一个空参的构造器
**数组可以看为一个特殊的类**
#### 5.6.2 equals()方法
##### 5.6.2.1 equals()方法的使用
+ equals是一个方法，而非运算符
+ 只能适用于引用数据类型
+ Object类中equals( )的定义
````
    public boolean equals(Object obj){
        return (this == obj);
    }
````
*说明Object类中定义的equals( )和==的作用是相同的：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体*  
+ 像String、Date、File、包装类等都重写了Object类的equals( )方法。重写以后，比较的不是两个引用的地址是否相同，而是**比较两个对象的"实体内容"是否相同**
+ 通常情况下，我们自定义的类如果使用equals( )的话，也通常是比较两个对象的"实体内容"是否相同。那么我们就需要对Object类中的equals( )进行重写。
    + 重写的原则：比较两个对象的实体内容是否相同。
##### 5.6.2.2 如何重写equals( )
手动重写举例  
````
    class User{
        String name;
        int age;
        //重写equals()方法
        public boolean equals(Object obj){
            if (obj == this){
                return true;
            }
            if (obj instanceof User){
                User u = (User)obj;
                return this.age == u.age && this.name.equals(u.name);
            }
        return false;
        }
    }
````  
*但是手动重写的equals方法并不完善，例如两个相同属性值的对象属于子父类关系时，instanceof方法判断的值为true，但在实际中我们希望判断值为false。而自动生成的方法会使用getClass方法判断两个对象是否属于同一个类，这样判断的返回结果就是false了*
开发中如何实现：自动生成
##### 5.6.2.3 回顾==运算符的使用
+ 可以在使用基本数据类型变量和引用数据类型变量中
+ 如果比较的是基本数据类型变量：比较两个变量保存的数据地址是否相等(不一定类型要相同)  
如果比较的是引用数据类型变量：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体。
+ ==符号使用时，必须保证符号左右两边的变量类型一致。
#### 5.6.3 toString方法
##### 5.6.3.1 toString( )的使用
+ 当我们输出一个对象的引用时，实际上就是调用当前对象的toString( )
+ Object类中toString( )的定义：
````
    public String toString(){
        return getClass.getName() + "@" + Integer.toHexString(hashCode());
    } 
````
+ 像String、Date、File、包装类等都重写了Object类中的toString( )方法。使得在调用对象的toString( )时，返回实体内容信息。
+ 自定义类也可以重写toString( )方法，调用此方法时，返回对象的实体内容。  

*注：当定义一个名为a的String型的对象，并赋值为null时，调用a.toString()会出现空指针异常(NullPointerException)，而正常打印结果System.out.println(a);则可以正常输出null。  
其原因是Object类中print方法的一种保护机制。具体参见源码*
````
    public void print(String s){
        if (s == null){
            s = "null";
        }
        write(s);
    }
````
##### 5.6.3.2 如何重写toString( )
````
    @Override
    public String toString(){
        return "Customer [name = " + name + ", age = " + age + "]"
    }
````
----
题目：  
1. final、finally、finalize的区别
2. ==和equals的区别

### 5.6.4 包装类的使用
#### 5.6.4.1 为什么要有包装类(或封装类)
为了使基本数据类型的变量具有类的特征，引入包装类。  
####  5.6.4.2 基本数据类型与对应的包装类
|基本数据类型|包装类|
|:---:|:---:|
|byte|Byte|
|short|Short|
|int|**Integer**|
|long|Long|
|float|Float|
|double|Double|
|boolean|Boolean|
|char|**Character**|
#### 5.6.4.3 需要掌握的类型间的转换(基本数据类型、包装类、String)
简易版：  
基本数据类型<--->包装类：JD 5.0 新特性：自动装箱与自动拆箱  
基本数据类型、包装类<--->String：调用String重载的ValueOf(KXxx xxx)  
String<--->基本数据类型、包装类：调用包装类的parseXxx(String s)  

*注意：转换时，可能会报NumberFormatException异常*

应用场景举例：  
① Vector类中关于添加元素，只定义了形参为Object类型的方法：  
> v.addElement(Object obj); //基本数据类型--->包装类--->使用多态

## 6 面向对象--下
### 6.1 关键字：static
理解含义：当我们编写一个类的时候其实就是在描述其对象的属性和方法，而并没有产生实质上的对象，只有当我们通过new关键字才会产生出对象，这是系统才会分配内存空间给对象，其方法才可以供给外部来调用。我们有时候希望无论是否产生了对象或者说无论产生了多少对象的情况下，**某些特定的数据在内存空间中只存在一份**，例如所有的中国人都有一个国家名称，每个中国人都共享这一个国家名称，所以不必再每个中国人的实例对象种都单独分配一个用于代表国家名称的变量。  


