# JavaNotebook
## **Carl的java笔记本**

## 1. Java语言概述
### Java三大特点
特点一：面向对象
+ 两个基本概念：类和对象
+ 三大特性：封装性，继承性，多态性

特点二：健壮性
+ 吸收了C/C++语言的特点但是去掉了其影响程序健壮性的部分（例如指针、内存申请与释放等），提供了一个相对安全的内存管理和访问机制

特点三：跨平台性
+ 通过Java语言编写的应用程序在不同的系统平台上都能够运行。

### Java的两种核心机制
+ Java虚拟机(Java Virtual Machine)
    + JVM是一个虚拟的计算机，具有指令集并使用不同的储存区域。负责执行指令，管理数据、内存、寄存器。
    + 对于不同的平台(Windows、Mac OS、Linux)有不同的虚拟机。
    + 只有当某平台提供了对应的虚拟机时，java程序才能够在此平台上运行。
    + java虚拟机机制屏蔽了底层运行平台的差别，真正实现了一次编译，到处运行
+ 垃圾回收机制(Garbage Collection)
    + 将不再运行的空间回收
    + 垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。
    + GC的基本原理：对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

**但是Java程序同样会出现内存泄漏和内存溢出问题！**

### JDK、JRE
JDK(Java Development Kit)
Java开发工具包
JDK是提供给Java开发人员使用的，其中也包含了JRE。
+ 其中的开发工具：编译工具(javac.exe)打包工具(jar.exe)等

JRE(Java Runtime Environment)
其中包含Java虚拟机(JVM)和Java程序所需要的核心类库等等。

### path环境变量
path环境变量：windows操作系统执行命令时索要搜寻的路径  
为什么要配置path环境变量：希望java的开发工具(javac.exe、java.exe)在任何的文件路径下都可以执行成功。

## 2. Java基本语法
### 1. 关键字(keyword)的定义和特点
+ 定义：被Java语言赋予了特殊含义，用作专门用途的字符串(单词)
+ 特点：关键字中所有的字母都为小**写**

### 2. 保留字  
现有Java版本尚未使用，但是以后版本可能会作为关键字使用。在自己命名一些标识符的时候要尽量避免使用这些保留字。
例如：goto、const

### 3. 标识符  
定义：凡是自己可以起名字的地方都叫做*标识符*。  
涉及到的结构：包名，**类名**，接口名，**变量名**，**方法名**，常量名  
标识符的命名规则：**必须遵守，否则会编译出错**
具体细则：
+ 由26个英文字母大小写，0-9，_或$组成
+ 数字不可以作为开头
+ 不可以使用关键字和保留字，但能包含关键字和保留字
+ Java中严格区分大小写。长度无限制。
+ 标识符不能包含空格。  
 
 标识符的命名规范：可以不遵守，不影响程序的编译和运行，但是要求遵守。  
 + 包名：多单词组成是所有字母都小写：xxxxyyyyzzzz
 + 类名、接口名：多单词组成时，所有的单词的首字母大写XxxxYyyyZzzz
 + 变量名、方法名： 多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写xxxYyyZzz
 + 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ  
 
 + 注意1：在起名字时，为了提高阅读性，要尽量有意义。"见名知意"
 + 注意2：Java采用Unicode字符集，因此标识符也可以用汉字声明，但是不建议使用。
 ### 4. 变量的分类
 #### 4.1 按数据类型分类
 ##### 基本数据类型(Primitive Type)
+ 数值型：数值型又分为整数类型(byte, short, int, long)和浮点型(float, double)
+ 字符型(char)
+ 布尔型(boolean)
 #### 引用数据类型(Reference Type)
 + 类(class)：其中包含字符串String 
 + 接口(Interface)
 + 数组([ ])
 
 详细说明：  
         1. 整型：  
         ① byte(1字节=8bit)\short(2字节)\int(4字节)\long(8字节)  
         ② byte范围：-128~127  
         ③. 声明long型变量，必须以"l"或"L"结尾  
         ④. 通常，定义整型变量时，使用int型。  
         2. 浮点型：float(4字节)\double(8字节)  
         ① 浮点型表示带小数点的数值  
         ② float表示数值的范围比long还大  
         ③ 定义float类型变量时，变量要以"f"或"F"结尾  
         ④ 通常，定义浮点型变量时，使用double型    
         ⑤ 浮点型的常量，默认类型为double    
         3. 字符型(1字符=2字节)  
         ① 定义char型变量，通常使用一堆''，内部只能写一个字符  
         ② 表示方式：1.声明一个字符。2.转义字符。3.直接使用Unicode值来表示字符型常量  
         4. 布尔型(boolean)  
         ① 只能取两个值之一：true、false  
         ② 常常在条件判断、循环结构中使用
         
 #### 4.2 按声明的位置分类
 ##### 成员变量
 其中包括不以static修饰的实例变量和以static修饰的类变量
 ##### 局部变量
 其中包括形参(方法，构造器中定义的变量)，方法局部变量(在方法内定义)和局部变量(在代码块中定义)
 
 #### 4.3 定义变量的格式
 数据类型 变量名 = 变量值  
  或  
 数据类型 变量名  
 变狼名 = 变量值  
 #### 4.4 变量定义中注意的点
 + 变量必须先声明，后使用
 + 变量都定义在其作用域内部。在作用域内，它是有效的。换句话说，除了作用域就失效了  
 + 同一个作用域内，不可以声明两个同名的变量
 #### 4.5 基本数据类型变量间运算规则
 ##### 4.5.1 涉及到的基本数据类型：除了boolean类型之外的其他七种。
 ##### 4.5.2 自动类型转换(只涉及7种基本数据类型)
 **结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。**  
 + byte-->char-->short-->int-->long-->float-->double  
 + 特别地，当byte、char、short三种类型的变量做运算时，结果为int型
##### 4.5.3 强制类型转换(只涉及7种基本数据类型)：自动类型提升运算的逆运算(不一定必须要容量小的数据类型转换为容量大的数据类型)，需要使用强转符( )，可能出现精度损失。
##### 4.5.4 String与8种基本数据类型之间的运算
+ String属于引用数据类型，翻译为字符串
+ 声明String变量时，使用一对一""
+ String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+
+ 运算的结果依然是String类型

"&"和"&&"的异同 
就是用上来讲，两个都是可以的   
&　不管前面的条件是否正确，后面都执行  
&&　前面条件正确时，才执行后面，不正确时，就不执行，就效率而言，这个更好  
开发中一般用"&&"
### 5. 流程控制
#### 5.1 if-else条件判断语句
+ else结构是可选的  
+ 针对于条件表达式  
    + 如果多个条件表达式之间是"互斥"关系(或者没有交集的关系)，那个判断和执行语句声明在上面还是下面无所谓。
    + 如果多个条件表达式之间由交集的关系，需要根据实际情况，考虑清楚应该将那个结构声明在上面。
    + 如果多个表达式之间有包含的关系，通常情况下，需要将范围小的生命在范围大的上面，否则范围小的就没有机会执行了。
+ if-else结构是可以互相嵌套的。
+ 如果if-else结构中的执行语句只有一行时，对应的一对{ }可以省略。
#### 5.2 switch-case选择结构
+ 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。  
调用完执行语句之后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止.
+ break，可以使用在switch-case结构中，表示一旦执行到此关键字，就会跳出switch-case结构。
+ switch结构中的表达式，只能是如下的6种数据类型之一：  
byte、short、char、int、枚举类型、String类型  
+ case之后只能声明变量。不能声明范围。
+ break关键字是可以选择的。
+ default：相当于if-else结构中的else  
default结构是可选的，而且位置是灵活的。
#####  如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。
#####  break在switch-case中是可选的
#### 5.3 循环结构
##### 5.3.1 循环结构的四要素
① 初始化条件  
② 循环条件  --->必须是boolean类型  
③ 循环体  
④ 迭代条件  
*通常情况下，循环都是因为条件②中循环条件返回false了*
##### 5.3.2 三种循环结构
a. for循环结构  
```
for(①; ②; ④){  
                ③  
            }  
```
执行过程：① - ② - ③ - ④ - ② - ③ - ④ - . . . - ②  
b. while循环结构
```
 ①  
 while(②){  
            ③;  
            ④;  
        }
```
*写while循环千万小心不要丢了迭代条件，一旦丢了可能会导致死循环*  
for和while循环总结：  
+ 开发中基本上都会从for、while循环中选择，实现循环结构
+ for和while循环是可以相互转换的
    + 区别：for循环和while循环的初始化条件部分的作用范围不同
+ 写程序时一定要避免出现死循环
    
*遍历数组，字符串一般可以用for；如果逻辑很复杂的话可以考虑用while*

c. do-while循环结构
```
①  
do {
        ③;  
        ④;  
    }   
while(②);  
```
执行过程：① - ③ - ④ - ② - ③ - ④ - . . . - ②  
*do-while循环至少会执行一次循环体  
开发中，使用for和while更多一些。较少使用do-while*

d. “无限循环”结构：while(true)或for(;;)
+ 如何结束一个循环结构
    + 方式一：当循环条件是false时
    + 方式二：在循环体中，执行break
    
e. 嵌套循环
+ 嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环
    + 内层循环：循环结构A
    + 外层循环：循环结构B
+ 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次
+ 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行的m*n次。
+ 外层循环控制行数，内层循环控制列数。
  
**衡量一个功能代码的优劣**
1. 正确性(代码功能是否正确)
2. 可读性(代码能不能够给其他程序员读懂)
3. 健壮性(考虑在多种情况下代码的可运行性)
4. 高效率与低存储：**时间复杂度**、空间复杂度(衡量算法好坏的标准)

|        |使用范围|循环中使用的作用(不同点)|相同点|  
|:----:|:----:|:----:|:----:|  
|break|switch-case循环结构中|结束当前循环|关键字后面不能声明执行语句|  
|continue|循环结构中|结束当次循环|关键字后面不能声明执行语句|  

*带标签的break和continue的使用*  

## 3. 数组
### 3.1 数组的概述
#### 3.1.1 数组的理解
数组(Array)是多个**相同类型**数据按照一定顺序排列的集合，并使用一个名字命名，并且通过编号的方式对这些数据进行统一管理。
#### 3.1.2 数组的相关概念
+ 数组名
+ 元素
+ 角标、下标、索引
+ 数组的长度：元素的个数
#### 3.1.3 数组的特点
+ 数组是顺序排列的
+ 数组属于**引用数据类型**的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型
+ 创建数组对象会在内存中开辟一整块**连续**的空间
+ 数组的长度一旦确定，就不能修改
#### 3.1.4 数组的分类
+ 按照维数：一维数组、二维数组、...
+ 按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组  

*数据结构：*  
*1. 数据与数据之间的逻辑关系：集合、一对一(链表)、一对多(树形结构)、多对多(社交网络)*  
*2. 数据的储存结构：*  
*线性表：顺序表(比如数组)、链表、栈、队列*  
*树形结构：二叉树*  
*图形结构：*  
*算法：排序算法、搜索算法*  

### 3.2 一维数组
#### 3.2.1 一维数组的声明与初始化
```
    int num         //声明
    num = 10        //初始化
    int id = 1001;  //声明+初始化

    int[] ids;      //声明
    //1.1 静态初始化：数组的初始化和数组元素的赋值操作同时进行
    ids = new int[]{1, 2, 3, 4, 5};
    //1.2 动态初始化：数组的初始化和数组元素的赋值操作分开进行
    String[] names = new String[5];   
    
    int[] array4 = {1, 2, 3, 4, 5};     //类型推断
```
#### 3.2.1 一维数组元素的引用
通过角标的方式调用
````
    //数组的角标(或索引)从0开始，到数组的长度-1结束
    names[0] = "张三";
    names[1] = "李四";
    names[2] = "王五";
````

#### 3.2.3 数组的属性：length
通过数组名.length调用
+ 数组一旦初始化，其长度就是确定的
+ 数组长度一旦确定，就不可修改

#### 3.2.4 一维数组的遍历
````
    //通过for循环遍历数组
    for(int i = 0; i < array.length; i++){
        System.out.println(array[i]);
    }
````
#### 3.2.5 一维数组元素的默认初始化值
+ 整型--->0
+ 浮点型--->0.0
+ char型--->0或'\u0000'，而非'0'
+ boolean型--->false
+ 引用数据类型--->null
#### 3.2.6 一维数组的内存解析
![一维数组的内存解析](https://pic2.zhimg.com/v2-43094dabbbc6fb0757a3ae2b18eb5c39_r.jpg)
![一维数组的内存解析](https://pic2.zhimg.com/v2-7b7e7d43901dbab5c3e265b25b668b75_r.jpg)
![一维数组的内存解析](https://pic2.zhimg.com/v2-1e27dbf3b7175f33f7cfdfb6fb113421_r.jpg)
![一维数组的内存解析](https://pic4.zhimg.com/v2-7a9ca791801af19714437351a217eac3_r.jpg)
*图片引用自知乎用户@Dunn.c，侵删*

### 3.3 二维数组
#### 3.3.1 如何理解二维数组
数组属于引用数据类型，数组的元素也可以是引用数据类型。一个一维数组的元素如果还是一个一维数组类型，则此数组称为二维数组。
#### 3.3.2  二维数组的声明和初始化
````
    int[] array = new int[]{1, 2, 3}; //一维数组
    //静态初始化
    int[][] array1 = new int[][]{{1, 2, 3,},{4, 5}, {6, 7, 8}};
    //动态初始化1
    String[][] array2 = new String[3][2];
    //动态初始化2
    String[][] array3 = new String[3][];
    //下面同样是正确的，但是写法并不标准
    int[] array4[] = new int[][]{{1, 2, 3,},{4, 5}, {6, 7, 8}};
    int[] array5 = {{1, 2, 3,},{4, 5}, {6, 7, 8}};
````

#### 3.3.3 如何调用二维数组的元素
````
    System.out.println(array[0][1]);
    System.out.println(array[0]);
````
#### 3.3.4 二维数组的属性  
````
    System.out.println(array.length);       //array数组外层有几个元素
    System.out.println(array[0].length);    //array数组外层中第0个数组内有几个元素
````
#### 3.3.5 遍历二维数组
````
    //双层for循环遍历二维数组
    for(int i = 0; i < array.length; i++){
        for(int j = 0; j < array[i]; j++){
        System.out.println(array[i][j] + " ");
        }
    System.out.println();
    }
````
#### 3.3.6 二维数组元素的默认初始化值
规定：二维数组分为外层数组的元素和内层数组的元素  
> int[ ][ ] array = new int[4][3];  
外层元素：array[0], array[1]等  
>内层元素：array[0][1], array[1][2]等

数组元素的默认初始化值  
针对于初始化方式一：比如： int[ ][ ] = array = new int[4][3];  
外层元素的初始化值为：地址值  
内层元素的初始化值为：与一维数组初始化情况相同

针对于初始化方式二：比如：int[ ][ ] = array = new int[4][ ];  
外层元素的初始化值为：null  
内层元素的初始化值为：不能调用，否则报错

#### 3.3.7 二维数组的内存结构
![二维数组的内存结构](https://img-blog.csdnimg.cn/20200221165644893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzcxMDk2,size_16,color_FFFFFF,t_70)
*引用自CSDN用户@Kafka_Hive_Flink，侵删*

### 3.4 数组的常见算法
#### 3.4.1 数组的创建与元素赋值
杨辉三角(二维数组)、回型数(二维数组)
#### 3.4.2 针对于数值型的数组
最大值、最小值、总和、平均数等
#### 3.4.3 数组的赋值与复制
````
    int[] array1, array2;
    array1 = new int[]{1, 2, 3, 4};
    //赋值
    array2 = new array1 //将array1保存的数组地址值赋给了array2，使得数组array1和array2共同指向堆空间的中同一个数组实体。
    //复制
    array2 = new int(array1.length) //重新创建了一个数组实体
    for(int i = 0; i < array2.length; i++){ //将array1数组的所有元素值赋给array2的数组
        array2[i] = array1[i];
    }
````
#### 3.4.4 数组元素的反转
````
    //方法一
    for (int i = 0; i < array.length / 2; i++){
        String temp = array[i];
        array[i] = array[array.length - i - 1];
        array[array.length - i -1] = temp;
    }
````
````
    //方法二
    for (int i = 0; j = array.length - 1; i < j; i++, j--){
        String temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
````
#### 3.4.5 数组中指定元素的查找：搜索、检索
##### 3.4.5.1 线性查找
实现思路：通过遍历的方式，一个一个的数据进行比较、查找  
适用性：具有普遍适用性
##### 3.4.5.2 二分法查找
实现思路：每次比较中间值，折半的方式检索。  
实用性：需要数组必须有序
#### 3.4.6 数组的排序算法
十大排序算法
+ 选择排序
    + 直接选择排序、*堆排序*
+ 交换排序
    + **冒泡排序、快速排序**
+ 插入排序
    + 直接插入排序、折半插入排序、Shell排序
+ *归并排序*
+ 桶式排序
+ 基数排序

1.衡量排序算法的优劣的指标  
+ 时间复杂度
+ 空间复杂度
+ 稳定性  
2.排序的分类
+ 内部排序
+ 外部排序(需要借助于磁盘)  
3.不同排序算法的时间复杂度  
![不同排序算法的时间复杂度](https://images2015.cnblogs.com/blog/975503/201702/975503-20170214211234550-1109833343.png)
*引用自博客园用户@simple_wxl,侵删*
#### 3.4.7 冒泡排序
````
        int[] array = new int[]{43, 32, 76, -98, 0, 64, 33};
        //冒泡排序
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + "  ");
        }
````

### 3.5 Arrays工具类的使用
#### 3.5.1 理解
+ 定义在Arrays.util包下
+ Arrays提供了很多操作数组的方法
#### 3.5.2 基本的使用
+ boolean equals(int[] a, int[] b) 判断两个数组是否相等。
+ String toString(int[] a) 输出数组信息。
+ void fill(int[] a,int val) 将指定值填充到数组之中。
+ void sort(int[] a) 对数组进行排序。
+ int binarySearch(int[] a, int key) 对排序后的数组进行二分法检索指定的值。

### 3.6 数组的常见异常
数组脚标越界异常(ArrayIndexOutOfBoundsException)  
````
    int[] array = new int[2];  
    System.out.println(array[2]);  
    System.out.println(array[-1]);  
````
访问到了数组中的不存在的脚标时发生。
  
空指针异常(NullPointerException)  
````
    int[] array = null;
    System.out.println(array[0]);
````
array引用没有指向实体，却在操作实体中的元素时产生。

## 4. 面向对象--上
### 4.1 类与对象
#### 4.1.1 面向对象的三天条主线
1. Java类及类的成员：属性、方法、构造器、代码块、内部类
2. **面向对象的三大特征**：封装性、继承性、多态性
3. 其他关键字：this、super、static、final、abstract、interface_test、package、import
#### 4.1.2 面向对象与面向过程
1. 面向过程：强调的是功能行为，以函数为最小单位，考虑如何去做。
2. 面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑由谁来做。 
#### 4.1.3 完成一个项目(或功能)的思路
+ 根据问题需要，选择问题所针对的**现实世界中的实体**
+ 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了**概念世界中的类**
+ 把抽象的实体用计算机语言进行描述，**形成计算机世界中类的定义**。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构
+ 将**类实例化成计算机世界中的对象**。对象是计算机世界中解决问题的工具
#### 4.1.4 面向对象中两个重要的概念
类：对**一类事物**的描述。是抽象的，概念上的定义。  
对象： 是**实际存在的**该事物的每个**个体**，因而也成为**实例**(Instance)  
面向对象程序设计的重点是**类的设计**  
设计类，就是设计**类的成员**  

二者的关系：  
对象是在类中通过new操作创造出来的，或着说派生出来的。
#### 4.1.5 面向对象思想落地实现的原则
1. 创建类，设计类的成员
2. 创建类的对象
3. 通过"对象.属性"或"对象.方法"调用对象的结构来解决问题  
几个概念的使用说明  
*属性=成员变量=field=域、字段*  
*方法=成员方法=函数=method*  
*创建类的对象=类的实例化=实例化类*
#### 4.1.6 对象的窗机与对象的内存解析
典型代码
````
    Employee e1 = new Employee();
    Employee e2 = new Employee();
    Employee e3 = e1;   //此时，e3与e1指向同一个地址值，即没有创建一个新对象
````
说明：  
如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性(仅限于static)。  
意味着：如果我们修改一个对象的属性a，它不会影响另外一个对象属性a的值。  
#### 4.1.7 匿名对象
匿名对象：我们创建的对象，没显式的赋给一个变量名。即为匿名对象  
特点：匿名对象只能调用一次  
举例：
````
    new Phone().sendEmail();
    new Phone().playGame();

    new Phone().price = 1999;
    new Phone().showPrice();

    //开发中的应用
    public void show(Phone phone){
        phone.sendEmail();
        phone.playGame();
    }
````
#### 4.1.8 万事万物皆对象
在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构  
+ Scanner，String等  
+ 文件：file  
+ 网络资源：URL  

涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类和对象。

---
JVM内存结构  
编译完源程序之后，生成一个或多个字节码(class)文件。  
我们使用JVM终得蕾姐在其和解释器对生成的字节码文件进行解释运行。意味着需要将字节码对相应的类加载到内存中，涉及到内存解析。  
![内存解析](https://img-blog.csdnimg.cn/2019040912492050.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Jvbmd0YW91cA==,size_16,color_FFFFFF,t_70)  
*引用自CSDN用户@_Rt，侵删*  

虚拟机栈即为平时提到的栈结构。**我们将局部变量储存在栈结构中**  
堆，我们将new出来的结构(如数组、对象)加载在堆空间中。  
对象的属性(非static)加载在堆空间中。  
方法区：类的加载信息、常量池、静态域

---

### 4.2 类的结构之一：属性
#### 4.2.1 对比属性与局部变量  
1. 相同点：  
1.1 定义变量的格式：数据类型 变量名 = 变量值  
1.2 先声明，后使用  
1.3 变量都有其对应的作用域   
2. 不同点：  
2.1 在类中声明的位置不同
+ 属性：直接定义在一对{ }内
+ 局部变量： 声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量  
2.2 关于权限修饰符的不同
+ 属性：可以在声明属性时，指明其权限，使用权限修饰符
    + 常用的权限修饰符：private、public、缺省、protected --->这些权限修饰符体现了封装性
+ 局部变量不能够使用权限修饰符  
2.3 默认初始化值的情况
+ 属性：类的属性，根据其类型，都默认初始化值。
    + 整型(byte、short、int、long)：0
    + 浮点型(float、double)：0.0
    + 字符型(char)：0或'\u0000'
    + 布尔型(boolean)：false
    + 引用数据类型(类、数组、接口)：null
+ 局部变量：没有默认初始化值
    + 意味着我们在调用局部变量之前，一定要显式赋值。特别地：形参在调用时，我们赋值即可。  
2.4 在内存中加载的位置：  
+ 属性：加载到堆空间中(非static)
+ 局部变量：加载到栈空间
### 4.3 类的结构之二：方法
方法：描述类应该具有的功能  
比如：  
Math类：sqrt( ) \ random( ) \ ...  
Scanner类：nextXxx( ) ...
Arrays类：sort( ) \ binarySearch( ) \ toString( ) \ equals( )\ ...

#### 4.3.1 举例：
````
    pubic void eat();
    public void sleep(int hour){ }
    public String getName(){ }
    public String getNation(String nation){ }
````
#### 4.3.2 方法的声明
````
    权限修饰符 返回值类型 方法名(形参列表){
            方法体
    }
````  
#### 4.3.3 说明：
##### 4.3.3.1 关于权限修饰符
默认方法的权限修饰符先都使用public。Java规定的4种权限修饰符：private、public、缺省、protected。  
##### 4.3.3.2 返回值类型
有返回值与没有返回值
1. 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同事，方法中需要使用return关键字来返回指定类型的常量或者变量："return 数据"。  
如果方法没有返回值，则方法声明时用void表示。通常情况下，没有返回值的方法中就不需要使用return。但如果使用的话也不会报错，但是只能以"return;"表示结束此方法。
2. 该不该返回值
+ 凭经验
+ 题目要求
##### 4.3.3.3 方法名
属于标识符，遵循标识符的规则和规范，要有见名知意的作用。
##### 4.3.3.4 形参列表
方法可以声明0个，1个或多个形参。  
1. 格式：数据类型1 形参1，数据类型2 形参2，...
2. 定义方法时该不该定义形参
+ 题目要求
+ 凭经验
##### 4.3.3.5 方法体
方法体：方法功能的实现。  

return关键字  
1.使用范围：使用在方法体中  
2.作用：  
+ 结束方法
+ 针对于返回值类型的方法，使用"return 数据"方法返回所需要的数据  

3.注意的点：return关键字后面不可以声明执行语句。  

**注意的是，可以调用当前类的属性或方法。特殊地：方法A中又调用了方法A：递归方法。**  
**方法中，不可以定义方法**

#### 4.3.4 方法的重载
##### 4.3.4.1 方法的重载的概念
定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可。  
"两同以不同"：同一个类、相同方法名；参数列表不同：参数个数不同，参数类型不同
##### 4.3.4.2 构成重载的举例
Arrays类中重载的sort( ) / binarySearch( )； PrintStream中的println( )  
##### 4.3.4.3 如何判断构成方法的重载
严格按照定义判断：量同以不同(跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系)
##### 4.3.4.4 如何确定类中某一个方法的调用
方法名--->参数列表

#### 4.3.5 可变个数形参的方法
##### 4.3.5.1 使用说明
1. jdk 5.0新增的内容  
2. 具体使用：  
2.1 可变个数形参的格式：数据类型...变量名。  
2.2 当调用可变个数形参的方法时，传入的参数个数可以是0个，1个，2个...。  
2.3 可变个数形参的方法与本类中的方法名相同，形参不同的方法之间构成重载。  
2.4 可变个数形参的方法与本类中的方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。  
2.5 可变个数形参在方法的形参中，必须声明在末尾。  
2.6 可变个数形参在方法的形参中，最多只能声明一个可变形参。  
##### 4.3.5.2 举例
````
    public void show(String s){
        System.out.println("show(String)");
    }
    public vodi show(String ... strs){
        System.out.println("Show(String ... strs)");
        for (int i = 0; i < strs; i++){
            System.out.println(strs[i]);
        }
    }
    //以下方法不能遇上一个方法同时存在(不构成重载)
    public void show(String[] strs){
    
    }
````


#### 4.3.5 Java的值得传递机制
##### 4.3.5.1 方法内的变量的赋值
如果变量是基本数据类型，此时赋值的是变量所保存的数据值。  
如果变量是引用数据类型，此时赋值的是变量做保存的数据的地址值。  
##### 4.3.5.2 针对于方法的参数概念
形参：方法定义时，声明的小括号内的参数  
实参：方法调用时，事迹传递给形参的参数  
##### 4.3.5.3 Java中参数的传递机制：值传递
规则：  
+ 如果参数是基本数据类型，此时实参赋给形参的是实参真实储存的数据值  
+ 如果参数是引用数据类型，此时实参赋给形参的是实参储存数据的地址值  
推广：  
+ 如果变量是**基本数据类型**，此时赋值的是变量所保存的**数据值**
+ 如果变量是**引用数据类型**，此时赋值的是变量所保存的数据的**地址值**

#### 4.3.6 Java的传递机制
##### 4.3.6.1 定义
递归方法：一个方法体内调用它自身
##### 4.3.6.2 如何理解递归方法
+ 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无需循环控制
+ 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环
##### 4.3.6.3 举例
````
    //计算1-n之间所有自然数的和
    public int getSum(int n){
        if (n == 1){
            return 1;
        }else{
            return n + getSum(n - 1);
        }
    }
````

### 4.4 面向对象的特征之一：封装与隐藏
#### 4.4.1 为什么要引入封装性
设计程序追求的是"**高内聚，低耦合**"。  
高内聚：类的内部数据操作细节自己完成，不允许外部干涉  
低耦合： 仅对外暴露少量的方法用于使用  
+ 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，**把该隐藏的隐藏起来，该暴露的暴露出来，这就是封装性的设计思想**。
#### 4.4.2 问题的引入
当我们创建了一个类的对象之后，我们可以通过”对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和储存范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。(比如：setLegs( )同时，我们需要避免用户再次使用"对象.属性"的方式对属性进行赋值。则需要将属性声明为私有的(private))。  
此时，针对于属性就体现了封装性。
*需要说明的是，封装性不仅仅体现在上述一个方面*
#### 4.4.3 封装性思想具体的代码体现：
体现一：将类的属性xxx私有化(private)，同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值
体现二：不对外暴露的私有的方法
体现三：单例模式(将构造器私有化)
体现四：如果不希望类在包外被调用，可以将类设置为缺省的。
#### 4.4.4. Java规定的四种权限修饰符(可以考虑将其等价为封装性)
##### 4.4.4.1 权限从小到大的顺序
private < 缺省 < protected < public
##### 4.4.4.2 具体的修饰范围
|修饰符|类内部|同一个包|不同包的子类|同一个工程|  
|:----:|:----:|:----:|:----:|:----:|  
|private|Yes|No|No|No|  
|缺省|Yes|Yes|No|No|  
|protected|Yes|Yes|Yes|No|    
|public|Yes|Yes|Yes|Yes|
##### 4.4.4.3 权限修饰符可以用来修饰的结构说明
4种权限修饰都可以用来修饰类的内部结构：属性、方法、构造器、内部类  
修饰类的权限修饰符只能使用缺省、public  

### 4.5 类的结构：构造器
#### 4.5.1 构造器(或构造方法)Constructor
##### 4.5.1.1 构造器的作用
+ 创建初始对象  
+ 初始化对象信息  
**只要造对象，就必须用到构造器**
##### 4.5.1.2 使用说明
+ 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器
+ 定义构造器的格式：权限修饰符 类名(形参列表){ }
+ 一个类中定义的多个构造器，彼此构成重载  
+ 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器
+ 一个类中，至少会有一个构造器  

#### 4.5.2 属性赋值顺序


a 默认初始化  
b 显式初始化  
c 构造器中初始化

---  
d 通过"对象.方法"或"对象.属性"的方式赋值  
以上操作的先后顺序：a - b - c - d  
#### 4.5.3 JavaBean
JavaBean的概念：所谓JavaBean，是指符合如下标准的Java类  
+ 类是公共的
+ 有一个**无参数**的公共的构造器
+ 属性，切对象的get，set方法  
### 4.6 关键字：this
#### 4.6.1 可以调用的结构
属性、方法; 构造器
#### 4.6.2 this调用属性、方法
this理解为：当前对象或当前正在创建的对象。  
1. **在类的方法中**，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是在通常情况下，我们都选择省略"this"。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。
2. **在类的构造器中**，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。但是通常情况下，我们都选择省略"this"。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。
#### 4.6.3
+ 我们在类的构造器中，可以显示的使用"this(形参列表)"方式，调用本类中指定的其它构造器
+ 构造其中不能通过"this(形参列表)"方式调用自己
+ 如果一个类中有n个构造器，则最多有n - 1个构造器使用了"this(形参列表)"
+ 规定:"this(形参列表)"必须声明在当前构造器的首行
+ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器

### 4.7 关键字package/import
#### 4.7.1 package的使用
#### 4.7.1.1 使用说明：
+ 为了更好地实现项目中类的管理，提供包的概念  
+ 使用package声明类或接口所属的包，声明在源文件的首行  
+ 包属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)  
+ 每"."一次，就代表一层文件目录  
**同一个包下，不能命名同名的接口、类**  
**不同的包下，可以命名同名的接口、类**
##### 4.7.1.2 JDK中主要包介绍
+ java.lang----包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能
+ java.net----包含执行与网络相关的操作的类和接口。
+ java.io ----包含能提供多种输入/输出功能的类。
+ java.util----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。
+ java.text----包含了一些java格式化相关的类
+ java.sql----包含了java进行JDBC数据库编程的相关类/接口
+ java.awt----包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S
#### 4.7.2 import的使用
import：导入  
1. 在源文件中显式的使用import结构导入指定包下的类、接口  
2. 声明在包的声明和类的声明之间  
3. 如果需要导入多个结构，则并列写出即可  
4. 可以使用"xxx.*"的方式，表示可以导入xxx包下的所有结构  
5. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构  
6. 如果使用的类或接口是本包下定义的，则可以省略import结构  
7. 在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示  
8. 使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入  
9. import static：导入指定类或接口中的静态结构：属性或方法  

## 5. 面向对象--中
### 5.1 面向对象的特征二：继承性
#### 5.1.1 为什么要有类的继承性(继承性的优点)
+ 减少了代码的冗余，提高了代码的复用性
+ 便于功能的拓展
+ 为之后多态性的使用提供了前提
#### 5.1.2 继承性的格式
> class A extends B{ }

+ A：子类、派生类、subclass
+ B：父类、超类、基类、superclass
#### 5.1.3 子类继承父类以后会有哪些不同
1. 体现：一旦子类A继承父类B以后，子类A中就获取了B中声明的所有属性和方法。**特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只是因为封装性的影响，是的子类不能直接调用父类的结构而已**。   
2. 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系并不同于子集和集合的关系。
#### 5.1.4 Java继承中的说明
+ 一个类可以被多个子类继承
+ Java中类的单继承性：一个类只能有一个父类
+ 子父类是相对的概念
+ 子类直接继承的父类，称为直接父类；间接继承的父类称为间接父类
+ 子类继承父类以后，就获取了直接弗雷以及所有间接父类中声明的属性和方法
#### 5.1.5 java.lang.Object类的理解
+ 如果我们没显式的声明一个类的父类的话，则粗类继承与java.lang.Object类
+ 所有的java(除java.lang.Object类之外都直接或间接的继承于java.lang.Object类)
+ 意味着，所有的java类具有java.lang.Object类声明的功能

### 5.2 方法的重写
#### 5.2.1 什么是方法的重写(override或overwrite)
重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作(因为父类的方法可能不适用于子类了)
#### 5.2.2 应用
重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写的方法。
#### 5.2.3 举例
````
    class Circle{
        public double findArea(){}  //求面积
    }
    class Cylinder extends Cirecle{
        public double findArea(){}  //求表面积
    }   
````
#### 5.2.4 重写的规则
方法的声明：
````
权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{  
                    方法体  
                }  
````
约定俗成：子类中的叫重写的叫重写的方法；父类中的叫被重写的方法
+ 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
+ 子类重写的方法的权限修饰符不小于父类中被重写的方法的权限修饰符
    +特殊情况：子类不能重写父类中声明为private权限的方法
+ 返回值类型
    + 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
    + 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以使A类或A类的子类
    + 父类被重写的方法的返回值类型是基本数据类型(比如double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
    + 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型
    + 子类和父类的同名同参数的方法要么都声明为static的(考虑重写，要么就都声明为static的)  
    
区分方法的重写和重载？  
答：1. 二者的概念    
2. 重载和重写的具体规则  
3. 重载：不表现为多态性  
重写：表现为多态性  
重载，是指允许存在多个同名方法，而这些方法的参数不同。根据编译方法不同的参数列表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。**它们的调用地址在编译期就绑定了**。java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。  
所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为"**早绑定**"或"**静态绑定**"。  
而对于多台，直等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为"**晚绑定**"或"**动态绑定**"。
 
### 5.3 关键字super
#### 5.3.1 super关键字可以理解为
父类的
#### 5.3.2 可以用来雕用的结构
属性、方法、构造器
#### 5.3.3 super调用属性、方法
1. 我们可以在子类的方法或构造器中，通过"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super"。  
2. 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须是显式的使用"super.属性"的方式，表明调用的是父类中是声明的属性。  
3. 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类被重写的方法时，则必须是显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。  
#### 5.3.4 super调用构造器
+ 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
+ "super.(形参列表)"的使用必须声明在子类构造器的首行
+ 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
+ 在构造器的首行，没显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super( )
+ 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器

### 5.4 子类对象实例化全过程
从结果上看：继承性  
+ 子类继承父类以后，就获取了父类中声明的属性或方法
+ 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
从过程上来看：  
当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类结构，所以才可以看到内存中父类的结构，子类对象才可以考虑进行调用

### 5.5 面向对象的特征三：多态性
#### 5.5.1 多态性的理解
可以理解为一个事物的多种形态
#### 5.5.2 何为多态性
对象的多态性：父类的引用指向子类的对象(或子类的对象赋给父类的引用)
> Employee e = new Manager();  
> Object obj = new Date();
#### 5.5.3 多态性的使用
多态性的使用：虚拟方法调用  
有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但是在运行期，我们实际执行的是子类重写父类的方法。  
总结： 编译看左边，运行看右边。
#### 5.5.4 多态性的使用前提
+ 类的继承关系
+ 方法的重写
#### 5.5.5 多态性的应用举例
```` 
    //举例一
    public void func(Animal animal){    //Animal animal = new Dog();
        animal.eat();
        animal.shout();
````
````
    //举例二
    public boid method(Object obj){

    } 
````
#### 5.5.6 多态性使用的注意点
对象的多态性，只适用于方法，不适用于属性(编译和运行都看左边)

#### 5.6.7 关于向上转型和向下转型
1. 向上转型：多态
2. 向下转型  
2.1 为什么使用向下转型：有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时只能调用父类声明的属性和方法。子类特有的属性和方法不能调用。  
如何才能调用子类特有的属性和方法：使用向下转型。  
2.2 如何实现向下转型  
使用强制类型转换符：( )  
2.3 使用时注意的点  
使用强制类型转换时，可能出现ClassCastException的异常。为了避免在向下转型时出现此异常，我们在向下转型之前，先进行instanceof判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。  
2.4 instanceof的使用  
a instanceof A：判断对象a是否是对象A的实例。如果是，返回true；如果不是，返回false。  
如果a instanceof A返回true，则a instanceof B也返回true。其中类B是类A的父类。  
要求a所属的类与类A必须是子类和父类的关系，否则编译错误。  

----
对多态性的理解：  
 + 实现代码的通用性
 + Object类中定义的public boolean equals(Object obj){ }  
 JDBC：使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)
 + 抽象类和接口的使用，如果没有多态性，这两部分就没有意义。(抽象类、接口不能实例化)

多态是编译时行为还是运行时行为？
运行时行为
````
    public static void main(String[] args){
        int key = new Random().nextInt(3);
        System.out.println(key);
        Animal animal = getInstance(key);
        animal.eat();
    }
````
 
### 5.6 Object类的使用
#### 5.6.1 java.lang.Object类的说明
+ Object类是所有java类的根父类
+ 如果在类的生命中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
+ Object类中的功能(属性、方法)具有通用性
    + 属性：无
    + 方法：equals() / toString() / getClass() / hashCode() / clone() / finalize() / wait() / notify()、notifyAll()
+ Object类只声明了一个空参的构造器
**数组可以看为一个特殊的类**
#### 5.6.2 equals()方法
##### 5.6.2.1 equals()方法的使用
+ equals是一个方法，而非运算符
+ 只能适用于引用数据类型
+ Object类中equals( )的定义
````
    public boolean equals(Object obj){
        return (this == obj);
    }
````
*说明Object类中定义的equals( )和==的作用是相同的：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体*  
+ 像String、Date、File、包装类等都重写了Object类的equals( )方法。重写以后，比较的不是两个引用的地址是否相同，而是**比较两个对象的"实体内容"是否相同**
+ 通常情况下，我们自定义的类如果使用equals( )的话，也通常是比较两个对象的"实体内容"是否相同。那么我们就需要对Object类中的equals( )进行重写。
    + 重写的原则：比较两个对象的实体内容是否相同。
##### 5.6.2.2 如何重写equals( )
手动重写举例  
````
    class User{
        String name;
        int age;
        //重写equals()方法
        public boolean equals(Object obj){
            if (obj == this){
                return true;
            }
            if (obj instanceof User){
                User u = (User)obj;
                return this.age == u.age && this.name.equals(u.name);
            }
        return false;
        }
    }
````  
*但是手动重写的equals方法并不完善，例如两个相同属性值的对象属于子父类关系时，instanceof方法判断的值为true，但在实际中我们希望判断值为false。而自动生成的方法会使用getClass方法判断两个对象是否属于同一个类，这样判断的返回结果就是false了*
开发中如何实现：自动生成
##### 5.6.2.3 回顾==运算符的使用
+ 可以在使用基本数据类型变量和引用数据类型变量中
+ 如果比较的是基本数据类型变量：比较两个变量保存的数据地址是否相等(不一定类型要相同)  
如果比较的是引用数据类型变量：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体。
+ ==符号使用时，必须保证符号左右两边的变量类型一致。
#### 5.6.3 toString方法
##### 5.6.3.1 toString( )的使用
+ 当我们输出一个对象的引用时，实际上就是调用当前对象的toString( )
+ Object类中toString( )的定义：
````
    public String toString(){
        return getClass.getName() + "@" + Integer.toHexString(hashCode());
    } 
````
+ 像String、Date、File、包装类等都重写了Object类中的toString( )方法。使得在调用对象的toString( )时，返回实体内容信息。
+ 自定义类也可以重写toString( )方法，调用此方法时，返回对象的实体内容。  

*注：当定义一个名为a的String型的对象，并赋值为null时，调用a.toString()会出现空指针异常(NullPointerException)，而正常打印结果System.out.println(a);则可以正常输出null。  
其原因是Object类中print方法的一种保护机制。具体参见源码*
````
    public void print(String s){
        if (s == null){
            s = "null";
        }
        write(s);
    }
````
##### 5.6.3.2 如何重写toString( )
````
    @Override
    public String toString(){
        return "Customer [name = " + name + ", age = " + age + "]"
    }
````
----
题目：  
1. final、finally、finalize的区别
2. ==和equals的区别

### 5.6.4 包装类的使用
#### 5.6.4.1 为什么要有包装类(或封装类)
为了使基本数据类型的变量具有类的特征，引入包装类。  
####  5.6.4.2 基本数据类型与对应的包装类
|基本数据类型|包装类|
|:---:|:---:|
|byte|Byte|
|short|Short|
|int|**Integer**|
|long|Long|
|float|Float|
|double|Double|
|boolean|Boolean|
|char|**Character**|
#### 5.6.4.3 需要掌握的类型间的转换(基本数据类型、包装类、String)
简易版：  
基本数据类型<--->包装类：JD 5.0 新特性：自动装箱与自动拆箱  
基本数据类型、包装类<--->String：调用String重载的ValueOf(KXxx xxx)  
String<--->基本数据类型、包装类：调用包装类的parseXxx(String s)  

*注意：转换时，可能会报NumberFormatException异常*

应用场景举例：  
① Vector类中关于添加元素，只定义了形参为Object类型的方法：  
> v.addElement(Object obj); //基本数据类型--->包装类--->使用多态

## 6 面向对象--下
### 6.1 关键字：static
#### 6.1.1 理解含义
理解含义：当我们编写一个类的时候其实就是在描述其对象的属性和方法，而并没有产生实质上的对象，只有当我们通过new关键字才会产生出对象，这是系统才会分配内存空间给对象，其方法才可以供给外部来调用。我们有时候希望无论是否产生了对象或者说无论产生了多少对象的情况下，**某些特定的数据在内存空间中只存在一份**，例如所有的中国人都有一个国家名称，每个中国人都共享这一个国家名称，所以不必再每个中国人的实例对象种都单独分配一个用于代表国家名称的变量。  
#### 6.1.2 可以用来修饰的结构：主要用来修饰类的内部结构
属性、方法、代码块、内部类  
构造器不能够用static  
#### 6.1.2 static修饰属性：静态变量(或类变量)
1. 属性按是否使用static修饰又分为：静态属性和非静态属性(实例变量)  
实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。修改其中一个对象的非静态属性时，不会影响其他对象中 同样的属性值。  
   
静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。但通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，会修改其他对象的此项属性。  

2. static修饰属性的其他说明：
2.1 静态变量随着类的加载而加载，随着类的抹去而抹去。可以通过"类.静态变量"的方式进行调用  
2.2 静态变量的加载要早于对象的创建  
2.3 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。
   
| | 类变量 | 实例变量 |  
|:----:|:----:|:----:|  
|类|yes|no|  
|对象|yes|yes|  
3 静态属性举例：System.out； Math.PI

#### 6.1.3 static修饰方法
静态方法、类方法  
+ 随着类的加载而加载，随着类的抹去而抹去。可以通过"类.静态方法"的方式调用  

| |静态方法|非静态方法|
|:---:|:---:|:---:|
|类|yes|no|
|对象|yes|yes|  
  
+ 静态方法中：只能调用静态的方法或者属性
+ 非静态方法中：既可以调用非静态的方法和属性，也可以调用静态的方法或属性
#### 6.1.4 static的注意点
+ 在静态的方法内部不能使用this关键字和super关键字
+ 关于静态属性和静态方法的使用，都从类和对象的生命周期角度理解
#### 6.1.5 如何判定属性和方法应该使用static关键字
关于属性：  
+ 属性可以被多个对象共享，不会随着对象之间的差异产生变化的，可以将属性声明为静态的。
+ 类中的常量也常常声明为static  

关于方法：  
+ 操作静态属性的方法通常设置为静态的
+ 工具类中的方法，习惯上声明为静态的。比如Math、Arrays、Collections
----
###单例模式
### 1. 设计模式的说明
#### 1.1 什么是设计模式
设计模式**是在大量的实践中总结和理论化之后优化的代码结构、编程风格、以及解决问题的思考方式**。
#### 常用的设计模式---23种经典的设计模式
+ 创建型模式
    + 工厂方法模式
    + 抽象工厂模式
    + 单例模式
    + 建造者模式
    + 原型模式
+ 结构型模式
    + 适配器型模式
    + 装饰器模式
    + 代理模式
    + 外观模式
    + 桥接模式
    + 组合模式
    + 享元模式
+ 行为型模式
    + 策略模式
    + 模板方法模式
    + 观察者模式
    + 迭代器型模式
    + 责任链模式
    + 命令模式
    + 备忘录模式
    + 状态模式
    + 访问者模式
    + 中介者模式
    + 解释器模式
  
----

### 2. 单例模式
#### 2.1 要解决的问题
所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统种，对某个类只能存在一个对象实例
#### 2.2 具体的代码实现
饿汉式： 
````
class Bank{
    //1。私有化类的构造器
    private Bank(){
    }
    //2.内部创建类的对象
    //4.要求此对象也必须声明为静态的
    private static Bank instance = new Bank();


    //3.提供公共的静态的方法，返回类的对象
    public static Bank getInstance(){
        return instance;
    }
}
````
懒汉式： 
````
class Test{
    //1.私有化类的构造器
    private Test(){
    }
    //2.先声明当前类的一个对象
    //4.此对象也必须声明为static的
    private static Test instance = null;

    //3.声明public、static的返回当前类对象的方法
    public static Test getInstance(){
        if (instance == null){
            instance = new Test();
        }
        return instance;
    }
}
````
#### 2.3 两种方式的对比
1. 饿汉式：  
缺点：对象加载时间过长  
优点：线程安全  
2. 懒汉式：   
优点：延迟对象的创建  
目前的写法缺点：线程不安全  

----

### 6.2 main( ) 的使用说明
+ main( )方法作为程序的入口
+ main( )方法也是一个普通的静态方法
+ main( )方法可以作为我们与控制台的交互方式(使用Scanner)   

如何将控制台获取的数据传给形参：String[] args？   
  运行时：java 类名 "Tom" "Jerry" "123" "true"
        System.out.println(args[0]);    //"Tom"
        System.out.println(args[3]);    //"true" --->Boolean.parseBoolean(args[3]);
        System.out.println(args[4]);    //报异常

### 6.3 类的成员之四：代码块
#### 6.3.1 代码块的作用
用来初始化类、对象的信息
#### 6.3.2 分类
代码块如果使用修饰符，那么他只能使用static  
分类：静态代码块与非静态代码块
#### 6.3.3 静态代码块
+ 内部可以有输出语句
+ 随着类的加载而执行，且执行一次(即类加载的时候)
+ 作用：初始化类的信息
+ 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
+ 静态代码块的执行要优先于非静态代码块的执行
+ 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
#### 6.3.4 非静态代码块
+ 内部可以有输出语句
+ 随着对象的创建而执行
+ 每创建一个对象，就执行一次非静态代码块
+ 作用：可以在创建对象时，对对象的属性进行初始化
+ 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法
#### 6.3.5 实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序
"由父及子，静态先行"

----

属性的赋值顺序
a 默认初始化
b 显式初始化 / 在代码块中赋值
c 构造器中初始化
d 有了对象以后，可以通过"对象.属性"或"对象.方法"的方式进行赋值

执行的先后顺序：a - b - c - d

----

### 6.4 关键字final
#### 6.4.1 可以用来修饰
类、方法、变量
#### 6.4.2 具体内容
1. final可以用来修饰一个类：此类不能被其他的类所继承。例如String类、System类、String和Buffer类。  
2. final可以用来修饰方法：表名此方法不可以被重写。比如Object类中的getClass;
3. final可以用来修饰变量，此时的“变量"就称为是一个常量  
3.1 final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化  
3.2 final修饰局部变量：尤其是使用final修饰形参时，表名此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能重新赋值。

*static final用来修饰属性：全局常量*

### 6.5 关键字：abstract
#### 6.5.1 可以用来修饰
类、方法
#### 6.5.2 具体的
abstract修饰的类：抽象类  
+ 此类不能实例化
+ 抽象中一定有构造器，便于子类实例化时调用(设计子类对象实例化的全过程)
+ 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作--->抽象的使用前提：继承性  

abstract修饰方法：抽象方法  
+ 抽象方法只有方法的声明，没有方法体
+ 包含抽象方法的类，一定是一个抽象类。繁殖，抽象类中可以没有抽象方法。
+ 只有当子类重写了父类中所有的抽象方法后，此子类才可以实例化
+ 若子类没重写父类中所有的抽象方法，则此子类也是一个抽象类，需要用abstract修饰。

#### 6.5.3 注意点
1. abstract不能用来修饰属性、构造器等结构  
2. abstract不能用来修饰私有方法、静态方法、final的方法、final的类

----
### 模板方法的设计模式
#### 1. 解决的问题
在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式
#### 2. 举例
````
public class TemplateTest {
    public static void main(String[] args) {
        Template t = new SubTemplate();
        t.spendTime();
    }
}

abstract class Template {
    //计算一段代码代码执行索要花费的的时间
    public void spendTime() {
        long start = System.currentTimeMillis();
        code();     //不缺定的部分，易变的部分。所以需要定义抽象
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start));
    }

    public abstract void code();
}

class SubTemplate extends Template {

    @Override
    public void code() {
        for (int i = 2; i <= 1000; i++) {
            boolean isFlag = true;
            for (int j = 2; j <= Math.sqrt(i); j++) {
                if (i % j == 0) {
                    isFlag = false;
                    break;
                }
            }
            if (isFlag) {
                System.out.println(i);
            }
        }
    }
} 
````
#### 3. 应用场景
+ 数据库访问的封装
+ Junit单元测试
+ JavaWeb的Servlet中关于doGet/doPost方法调用
+ Hibernate中模板程序
+ Spring中JDBCTemlate、HibernateTemplate等

----

### 6.6 关键字：interface
#### 6.6.1 使用说明
1 接口使用interface来定义  
2 Java中，接口和类是并列的两个结构  
3 如何定义接口：定义接口中的成员  
3.1 JDK7以前：只能定义全局常量和抽象方法  
+ 全局常量：public static final(但是，书写时可以省略不写)  
+ 抽象方法：public abstract  

3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法  
4. 接口中不能定义构造器！这意味着接口不能实例化。  
5. Java开发中，接口都通过让类去实现(implements)的方式使用。  
+ 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化。  
+ 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类  
6. Java类可以实现多个接口--->弥补了Java单继承性的局限  
> 格式： class AA extends BB implements CC, DD, EE...  
7. 接口与接口之间可以继承，且可以多继承  
*********************************************
8. 接口的具体使用：体现多态性  
9. 接口实际上可看做是一种规范  
 
#### 6.6.2 举例
````
class interface_test.Computer{     
    public void transferData(interface_test.USB usb){  //interface_test.USB usb = new interface_test.Flash();
        usb.start();
        System.out.println("具体传输数据的细节");
        usb.stop();
    }
}

interface interface_test.USB{
    //常量：定义了长、款、最大最小的涮熟速度等
    void start();
    void stop();
}

class interface_test.Flash implements interface_test.USB{

    @Override
    public void start() {
        System.out.println("U盘开始工作");
    }

    @Override
    public void stop() {
        System.out.println("U盘结束工作");
    }
}

class interface_test.Printer implements interface_test.USB{

    @Override
    public void start() {
        System.out.println("打印机开启工作");
    }

    @Override
    public void stop() {
        System.out.println("打印机结束工作");
    }
}
````
#### 6.6.3 体会面向接口的思想
面向接口编程：我们在应用程序中调用的结构都是JDBC中定义的接口，不会出现具体某一个数据库厂商的API。
#### 6.6.4 Java8中关于接口的新规范
+ 接口中的静态方法只能通过接口来调用
+ 通过实现类的对象，可以调用接口中的默认方法
    + 如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
+ 如果子类(或实现类)继承的父类实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，
    + 默认调用的时父类中的同名同参数的方法--->类优先原则
+ 如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类中没有重写此方法的情况下，报错。--->接口冲突  
    + 这需要我们在实现类中必须重写此方法
----
如何在子类(或实现类)的方法中调用父类、接口中被重写的方法
> method( );  //调用自己重写的方法  
> super.method( );    //调用父类中重写的方法  
> InterfaceJava8.super.method( );     //调用接口中的默认方法

抽象类和接口的异同？  
相同点：不能实例化；都可以包含抽象方法。  
不同点：  
1. 抽象类和接口(Java7, Java8, Java9)的定义、内部结构解释说明
2. 类：单继承性   接口： 多继承  
类与接口：多实现
   
----
### 代理模式
#### 1. 解决的问题
代理模式时Java开发中使用比较多的一种设计模式。代理设计就是为其他对象提供一种代理，以控制对这个对象的访问。  
#### 2. 应用场景
+ 安全代理：屏蔽对真实角色的直接访问
+ 远程代理： 通过代理类处理远程方法调用
+ 延迟加载：先加载轻量级的代理对象，真正需要在加载真实对象  
分类：
+ 动态代理(静态定义代理类)
+ 动态代理(动态生成代理类)

### 6.7 类的结构：内部类
#### 6.7.1 定义
Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。
#### 6.7.2 内部类的分类
+ 成员内部类(静态、非静态)
+ 局部内部类(方法内、代码块内、构造器内)
#### 6.7.3 成员内部类的理解
一方面，作为外部类的成员：  
+ 滴哦用外部类的结构
+ 可以被static修饰
+ 可以被4种不同的权限修饰  

另外一方面，作为一个类：
+ 类内可以定义属性、方法、构造器等
+ 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
+ 可以被static修饰
#### 6.7.4 成员内部类
1. 如何创建成员内部类的对象(静态的、非静态的)
````
    //创建静态的Dog实例(静态的成员内部类)
    Person.Dog dog = new Person.Dog();
    
    //创建非静态的Bird实例(非静态的成员内部类)
    //Person.Bird bird = new Person.Bird(); //错误的
    Person p = new Person();
    Person.Bird bird = p.new Bird();
````
2. 如何在成员内部类中调用外部类的结构
````
class Person{
    String name = "小明";
    //非静态成员内部类
    class Bird{
        String name = "杜鹃";

        public void dispalay(String name){
            System.out.println(name);   //方法的形参
            System.out.println(this.name);   //内部类的属性
            System.out.println(Person.this.name);   //外部类的属性        
        }
    }  
}
````
#### 6.7.5 局部内部类的使用
````
    return new Comparable(){
    
        @Override
        public int compareTo(Object o){
            return 0;
        }
    }
````
*注意点：在局部内部类的方法中(比如：show)，如果调用局部内部类所声明的方法种的局部变量的话，要求此局部变量声明为final*
````
//举例
    public void method(){
        //局部变量
        int num = 10;   //JDK7之前版本需显式声明num为final，JDK8及以后版本不需要，但默认其还是一个final的。这是一个规定。
        
        class AA{
            public void show(){
                num = 20;   //报错：final值不允许修改
                System.out.println(num);
            }
        }
    }
````

总结：成员内部类和局部内部类在编译后，都会生成class文件。  
格式：  
成员内部类：外部类$内部类名.class  
局部内部类：外部类$ 内部类名.class

## 7. 异常处理
### 7.1 异常
#### 7.1.1 异常的体系结构
![java异常的体系结构](https://img-blog.csdn.net/20150107221255554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGQ4NjQxNDAxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  
*引用自CSDN用户@LiZhen798*  
#### 7.1.2 从程序的执行过程，看编译时异常和运行时异常
编译时异常：执行javac.exe命名时，可能出现的异常  
运行时异常：执行java.exe命令时，可能出现的异常
#### 7.1.3 常见的异常类型，举例
````
    /***********编译时异常***********/
    @Test
    public void test7(){
        File file = new File("hello.txt");
        FileInputStream fis = new FileInputStream(file);
        int data = fis.read();
        while(data!=-1){
            System.out.println((char) data);
            data = fis.read();
        }
        fis.close();
    }
    /***********运行时异常***********/
    //ArithmeticException
    @Test
    public void test6(){
        int a = 10, b = 0;
        System.out.println(a / b);
    }

    //InputMismatchException
    @Test
    public void test5(){
        Scanner input = new Scanner(System.in);
        int Demo = input.nextInt();
        System.out.println(Demo);
    }

    //NumberFormatException
    @Test
    public void test4(){
        String string = "abc";
        int num = Integer.parseInt(string);
    }

    //ClassCastException
    @Test
    public void test3(){
        Object obj = new Date();
        String string = (String)obj;
    }

    //ArrayIndexOutOfBoundsException
    @Test
    public void test2(){
        int array[] = new int[10];
        System.out.println(array[10]);
    }

    //NullPointerException
    @Test
    public void test1(){
        int[] arr = null;
        System.out.println(arr[3]);

        String string = null;
        System.out.println(string.charAt(0));
    }

````

### 7.2 异常处理
#### 7.2.1 java异常处理的抓抛模型
过程一："抛"： 程序在正常的执行过程中，一旦出现异常，就会在异常代码出生成一个对应异常类的对象，并将此对象抛出。  
一旦抛出对象，其后的代码便不再执行。  
关于异常的产生：  
1. 系统自动生成的异常对象  
2. 手动的生成一个异常对象并抛出(throw)  

过程二："抓"：可以理解为异常处理的两种方式：  
1. try-catch-finally  
2. throws  

#### 7.2.2 异常的处理方式一：try-catch-finally
1. try-catch-finally的使用
````
    try{
        //可能出现异常的代码
    }catch(异常类型1 变量名1){
        //处理异常的方式1
    }catch(异常类型2 变量名2){
        //处理异常的方式2
    }catch(异常类型3 变量名3){
        //处理异常的方式3
    }
    ......
    finally{
    //一定会执行的代码
    }
````
说明：
1. finally时可选的，不一定要写  
2. 使用try将可能出现异常的代码包装起来，执行过程中，一旦出现异常，就会生成一个对应异常类的对象。根据此对象的类型，去catch种进行匹配。  
3. 一旦try中的对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构(在没有写finally的前提下)，继续执行后面的代码。  
4. catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下没有影响。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错。  
5. 常用的异常对象处理方式：  
   5.1 String getMessage( )      
   5.2 printStackTrace( )  
6. 在try结构中声明的变量，除了try结构就不能调用了。可以在try结构体外先声明变量，并赋默认值，即可在结构外调用该变量。
7. try-catch-finally结构可以嵌套。  

总结1：使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍有可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常延迟到运行时出现。  
总结2：开发时，由于运行时异常比较常见，所以我们通常不针对运行时异常编写try-catch-finally。针对于编译时异常，一定要考虑异常的处理。  
2. finally的再说明   
2.1 finally是可选的  
2.2 finally声明的是一定会被执行的代码。即使catch中又出现异常了，或者try中有return语句，catch中有return语句等情况。  
2.3 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，需要自己手动进行资源释放。此时的资源释放，就需要声明在finally中。  
3. final、finally、finalize区别
类似：  
   throw和throws  
   Collection和Collections   
   String、StringBuffer、StringBuilder  
   ArrayList、LinkedList  
   HashMap、LinkedHashMap  
   重写和重载  
   
结构不相似：  
抽象类、接口  
==、equals( )
sleep( )、wait
#### 7.2.3 异常处理方式二
"throws + 异常类型“此方法在执行时，可能会抛出异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后面的异常类型时，就会被抛出。异常代码后的代码将不再执行。

#### 7.2.4 对比两种处理方式
try-catch-finally：真正的处理掉了异常  
throws：只是将异常抛给了方法的调用者，并没有将异常真正的处理掉。  
#### 7.2.5 开发中如何选择异常处理方式
开发中如何选择使用try-catch-finally  还是使用throws  
+ 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。  
+ 执行的方法A中，又先后调用了另外几个方法，这几个方法是递进关系执行的。建议这几个方法使用throws方式进行处理。而执行的方法A可以考虑使用try-catch-finally方式进行处理。

方法重写的规则之一  
子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。  

### 7.3 手动抛出异常对象
#### 7.3.1 使用说明
在程序执行中，除了自动抛出异常对象的情况之外，还可以手动的throw一个异常类的对象。
#### 7.3.2 问题
throw和throws的区别  
throw表示抛出一个异常类的对象，生成异常对象的过程。声明在方法内。
throws属于异常处理的一种方式，声明在方法的声明处
#### 7.3.3 举例
````
public class StudentTest {
    public static void main(String[] args) {
        try {
            Student s = new Student();
            s.register(-10001);
            System.out.println(s);
        } catch (Exception e) {
//            e.printStackTrace();
            System.out.println(e.getMessage());
        }
    }
}

class Student {
    int id;
    public void register(int id) throws Exception {
        if (id > 0) {
            this.id = id;
        } else {
//            System.out.println("输入非法");
            //手动抛出异常对象
//            throw new RuntimeException("您的输入非法！");
//            throw new Exception("您的输入非法！");
        throw new MyException("不能输入负数");
        }
    }
}
````

### 7.4 自定义异常类
#### 7.4.1 如何自定义异常类
1. 继承于现有的异常结构：RuntimeException、Exception  
2. 提供全局变量：serialVersionUID
3. 提供重载构造器
````
public class MyException extends RuntimeException{
    static final long serialVersionUID = -7034897190735766939L;

    public MyException(){

    }

    public MyException(String msg){
        super(msg);
    }
}
````

## 8. 多线程
### 8.1 程序、进程、线程的理解
#### 8.1.1 程序(Program)
概念：是为了完成特定任务，用某种语言编写的一组指令的集合。指一段**静态的代码**。
#### 8.1.2 进程(process)
概念：程序的一次执行过程，或是*正在运行的一个程序**。  
说明：**进程作为资源分配的单位**，系统在运行时会为每个进程分配不同的内存区域。   
每个线程拥有自己独立的栈和程序计数器。  
多个线程贡献同一个进程中的结构：方法区、堆。  
#### 8.1.3 线程(thread)
进程可以细化为多个线程。  
概念：进程可以进一步细化为线程，是一个程序内部的一条执行路径。  
说明：线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。

### 8.2 并行与并发
#### 8.2.1 单核CPU与多核CPU的理解
+ 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把它"挂起"(防着他不管，等他准备好交钱再去收费)，但是因为CPU时间单元特别短，因此感觉不出来。
+ 如果视多核的话，才能更好的发挥多线程的效率
+ 一个java应用程序java.exe，其实至少有三个线程：main()主线程,gc()垃圾回收线程，异常处理线程。当然如果发生异常会影响主线程。   
#### 8.2.2 并行与并发的理解
+ 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。
+ 并发： 一个CPU(采用时间片)同时执行多个任务。
### 8.3 创建多线程的两种方式
#### 方式一：继承Thread类的方式
````
    //1. 创建一个继承于Thread类的子类
    class MyThread extends Thread{

        //2. 重写Thread类中的run()
    @Override
    public void run(){
        for (int i = 1; i < 10000; i++) {
            if (i % 2 == 0){
                System.out.println(i);
            }

        }
    }
}
public class ThreadTest{
    public static void main(String[] args) {
        //3. 创建Thread子类的对象
        MyThread thread = new MyThread();

        //4. 通过此对象调用start()
        /*
        * 1. 启动当前线程
        * 2. 调用当前线程的run()
        * */
        thread.start();

        //在main线程中执行
        for (int i = 1; i < 10000; i++) {
            if (i % 2 == 0){
                System.out.println(i + "************************");
            }
        }
    }
}
````
说明两个问题：  
问题一：我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。  
问题二：如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start方法。  
#### 方式二
````
public class ThreadTest1 {
    public static void main(String[] args) {
        //3. 创建实现类的对象
        MThread mThread = new MThread();
        //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread对象
        Thread thread = new Thread(mThread);
        //5. 通过Thread类的对象调用start()
        thread.setName("线程一");
        thread.start();

        //再启动一个线程，遍历100以内的偶数
        Thread thread1 = new Thread(mThread);
        thread1.setName("线程二");
        thread1.start();
    }
}

//1. 创建一个实现了Runnable接口的类
class MThread implements Runnable{

    //2. 实现类去实现Runnable中的抽象方法: run()
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}
````

两种方式的对比：  
比较创建线程的两种方式  
开发中，优先选择：实现Runnable接口的方式  
原因：
1. 实现的方式没有类的单继承的局限性  
2. 实现的方式更适合来处理多个线程有共享数据的情况  

联系：Thread类也是实现了Runnable接口  
相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中  
   目前这两种方式启动线程所调用的都是Thread类中的start()方法。  

### 8.4 Thread类中的常用方法
1. start()：启动当前线程；调用当前线程的run()
2. run():通常需要重写Thread类中的此方法，将创建的线程需要执行的操作声明在此方法中
3. currentThread()：静态方法，返回当前代码的线程
4. getName()：获取当前线程名字
5. setName()：设置当前线程的名字
7. join()：在线程a中调用线程b的join()，此时线程a进入阻塞状态，直到线程b完全执行完之后，线程a才结束阻塞状态。
8. stop()：已过时。当执行此方法时，强制结束当前线程。
9. sleep(long millisecond)：让当前线程"睡眠"指定的millisecond毫秒。在指定的millisecond毫秒时间内，当前线程是阻塞状态。
10. isAlive()：判断当前线程是否存活。

线程的优先级
1. MIN_PRIORITY: 1
2. NORM_PRIORITY: 5 ---> 默认优先级
3. MAX_PRIORITY: 10

如何获取和设置当前线程的优先级  
getPriority()：获取线程的优先级  
setPriority()：设置线程的优先级  
说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。

线程通信：wait() / notify() / notifyAll()：此三个方法是定义在Object类中的。  

### 8.5 Thread的生命周期
#### 图示：  
![线程的生命周期](https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190722214114154-276488899.png)  
*引用自博客园用户@Java蚂蚁*
#### 说明
1. 生命周期关注两个概念：状态、相应的方法
2. 关注：状态a--->状态b：哪些方法执行了(回调方法)  
某个方法主动调用：状态a--->状态b
3. 阻塞：临时状态，不可以做为最终状态  
死亡：最终状态
   
### 8.6 线程的同步机制
#### 8.6.1 背景
例子：创建一个窗口卖票，总票数为100张，使用时限Runnable接口的方式  
1. 问题：买票过程中，出现了重票、错票--->出现了线程的安全问题  
2. 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票  
3. 如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能改变。
#### 8.6.2 Java解决方案：同步机制
java中，通过同步机制解决线程的安全问题  
#### 方式一：同步代码块  
> synchronized(同步监视器){  
> //需要被同步的代码  
> }  

说明：操作共享数据的代码，即为需要同步的代码。--->不能够包含过多或过少代码  
**共享数据**：多个线程共同操作的变量。如本例中的ticket。  
**同步监视器**：俗称锁。任何一个类的对象都可以充当锁  
要求：**多个线程必须要共用同一把锁**   
补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器，在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。  

#### 方式二：同步方法
如果操作数据共享的代码完整的声明在一个方法中我们可以将此方法声明为同步的。
同步的方式：解决了线程的安全问题。---好处  
操作同步代码时只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低一些。 ---局限性  
#####关于同步方法的总结
1. 同步方法依然涉及到同步监视器，只是不需要显式的声明
2. 非静态的同步方法，同步监视器时：this
3. 对于静态方法，同步监视器是当前类本身

#### 方式三：lock锁
##### synchronized( )与Lock方法的异同  
相同：都可以解决线程安全问题   
不同：synchronized机制在执行完相应的同步代码以后，自动释放同步监视器  
Lock需要手动的启动同步(lock( ))，同时结束同步也需要手动实现(unLock( ))  

使用的优先顺序：Lock--->同步代码块(已经进入了方法体，分配了相应资源)--->同步方法(在方法体之外)

#### 8.6.3 利弊
利：同步的方式解决了线程的安全问题  
弊：操作同步代码时，只能由一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。  

#### 8.6.4 线程安全的单例模式(懒汉式)
````
public class Singleton {
}

class Bank {
    private Bank() {
    }

    private static Bank instance = null;

    public static synchronized Bank getInstance() {     //线程安全
//        if (instance == null) {
//            instance = new Bank();
//        }
//        return instance;

        //效率更高
        if (instance == null) {
            if (instance == null) {
                instance = new Bank();
            }
        }
        return instance;
    }
}
````

#### 8.6.5 死锁
死锁的理解：不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。  
使用同步时，要避免出现死锁。  

### 8.7 线程通信
#### 8.7.1 线程通信涉及到的三个方法
* wait( ): 一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
* notify( ): 一旦执行此方法，就会唤醒被wait的一个线程，如果有多个线程被wait，就唤醒优先级高的那个。
* notifyAll( ): 一旦执行此方法，就会唤醒所有被wait的线程。

#### 8.7.2 具体说明
* wait( ), notify( ), notifyAll( )三个方法必须使用在同步代码块或同步方法中。
* wait( ), notify( ), notifyAll( )三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则会出现IllegalMonitorStateException异常
* wait( ), notify( ), notifyAll( )三个方法是定义在java.lang.Object包中的。

#### 8.7.3 题目
sleep和wait方法的异同  
相同点：只要执行，就会使得当前的线程进入阻塞状态  
不同点：
1. 两个方法声明的位置不同：Thread类中声明sleep( )，Object类中声明wait( )  
2. 调用的要求不同：sleep( )可以在任何需要的场景下调用。wait( )必须使用在同步代码块或同步方法之中  
3. 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep( )不会释放锁，wait( )会释放锁。  

#### 8.7.4 小结
释放锁的操作：  
+ 当前线程的同步方法、同步代码块执行结束
+ 当前线程在同步代码块、同步方法中遇到了break、return终止了该代码块、该方法的继续执行
+ 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束
+ 当前线程在同步代码块、同步方法中执行了线程对象的wait( )方法，当前线程暂停，并释放锁  

不会释放锁的操作：  
+ 线程执行同步代码块或同步方法时，程序调用Thead.sleep( )、Thread.yield( )方法暂停当前线程执行。
+ 线程执行同步代码块时，其他线程调用了该线程的suspend( )方法将该线程挂起，该线程不会释放锁(同步监视器)。
    + 应该尽量避免使用suspend( )和resume( )来控制线程
    
### 8.8 JDK5.0新增线程创建方式
#### 新增方式一：实现Callable接口
````
class NumThread implements Callable{
    //2. 实现call方法，将此线程需要执行的操作声明在call方法中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i < 100; i++) {
            if (i % 2 ==0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}

public class CallableTest {
    public static void main(String[] args) {
        //3. 创建Callable接口实现类的对象
        NumThread numThread = new NumThread();
        //4. 将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5. 将FutureTask类的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()。
        new Thread(futureTask ).start();

        try {
            //6. 获取Callable中的call方法的返回值
            //get方法的返回值即为FutureTask构造器Callable实现类重写的call的返回值
            Object sum = futureTask.get();
            System.out.println(sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
````
#### 说明
如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式更强大？  
1. call()方法可以有返回值  
2. call()可以抛出异常，被外部操作捕获，获取异常信息  
3. Callable支持泛型  

#### 新增方式二：线程池
````
class NumberThread implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            if (i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

public class ThreadPool {
    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;     //强制转换
        //设置线程池的属性
        service1.setCorePoolSize(15);
//        service1.setMaximumPoolSize();
//        ...

        //2. 执行指定的线程的操作。需要提供实现Runnable接口或Callable接口的实现类的对象
        service.execute(new NumberThread());    //适用于Runnable
//        service.submit();       //适用于Callable
        service.shutdown();     //3. 关闭连接池
    }
}
````
#### 说明
好处：  
1. 提高响应速度(减少了创建新线程的时间)  
2. 降低资源消耗(重复利用线程池中的线程，不需要每次都创建)  
3. 便于线程管理  

corePoolSize:核心池的大小  
maximumPoolSize:最大线程数  
keepAliveTime:线程没有任务时最多保持多长时间后会终止  
...

## 9 Java常用类
### 9.1 java.lang.String类的使用
#### 9.1.1 概述
String字符串：使用一对" "表示   
1. String声明为final的，表示不可被继承。  
2. String实现了java.io.Serializable接口：表示字符串是支持序列化的。  
实现了Comparable<String>接口：表示String可以比较大小。  
3. String内部定义了final char[ ] value用于储存字符串数据
4. 通过字面量的方式(区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)
5. 字符串常量池是不会存储相同内容(使用String类的equals( )比较，返回true)的字符串的。  

#### 9.1.2 String的不可变性
说明  
+ 当对字符串重新赋值时，需要重写指定内存区域，不能使用原有的value进行赋值  
+ 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value赋值  
+ 当调用String的replace( )方法时修改指定的字符或字符串时，也需要重新指定内存区域，不能使用原有的value赋值    


#### 9.1.3 String实例化的不同方式
##### 9.1.3.1 方式说明
String的实例化方式  
方式一：通过字面量定义的方式  
方式二：通过new+构造器的方式  
##### 9.1.3.2 代码举例
````
//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。
String s1 = "javaEE";
String s2 = "javaEE"
//通过new + 构造器的方式：此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。
String s3 = new String("javaEE");
String s4 = new String("javaEE");

System.out.println(s1 == s2);   //true
System.out.println(s1 == s3);   //false
System.out.println(s1 == s4);   //false
System.out.println(s3 == s4);   //false
````
##### 9.1.3.3 问题
String s = new String("abc");方式构建对象，在内存中创建了几个对象？  
两个：一个是堆空间中new结构，两一个是char[ ]对应的常量池中的数据"abc"。  

#### 9.1.4 字符串拼接方式赋值的对比
##### 说明
总结：常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量  
只要有一个是变量，结果就在堆中  
如果拼接的结果调用intern()方法，返回值就在常量池中  
##### 代码举例
````
    @Test
    public void test1(){

        String s1 = "aaa";
        String s2 = "111";

        String s3 = "aaa111";
        String s4 = "aaa" + "111";
        String s5 = s1 + "111";
        String s6 = "aaa" + s2;
        String s7 = s1 + s2;

        System.out.println(s3 == s4);   //true
        System.out.println(s3 == s5);   //false
        System.out.println(s3 == s6);   //fasle
        System.out.println(s5 == s6);   //false
        System.out.println(s3 == s7);   //false
        System.out.println(s5 == s6);   //false
        System.out.println(s5 == s7);   //false
        System.out.println(s6 == s7);   //false

        String s8 = s5.intern();        //返回值得到的s8使用的常量池中已经存在的"aaa111"
        System.out.println(s3 == s8);   //true
````
##### 常用方法
+ int length()：返回字符串的长度：return value.length  
+ char charAt(int index)： 返回某索引处的字符return value[index]  
+ boolean isEmpty()：判断是否是空字符串：return value.length == 0  
+ String toLowerCase()：使用默认语言环境，将 String中的所有字符转换为小写  
+ String toUpperCase()：使用默认语言环境，将 String中的所有字符转换为大写  
+ String trim()：返回字符串的副本，忽略前导空白和尾部空白  
+ boolean equals(Object obj)：比较字符串的内容是否相同  
+ boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写  
+ String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”  
+ int compareTo(String anotherString)：比较两个字符串的大小  
+ String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。  
+ String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。  
+ boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束  
+ boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始  
+ boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始  
+ boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char值序列时，返回true  
+ int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引  
+ int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出 现处的索引，从指定的索引开始  
+ int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引  
+ int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索  
  
  *注：indexOf和lastIndexOf方法如果未找到都是返回-1*  

+ String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar替换此字符串中出现的所有 oldChar得到的。  
+ String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。  
+ String replaceAll(String regex, String replacement)：使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。  
+ String replaceFirst(String regex, String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串。  
+ boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。  
+ String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。  
+ String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。  

#### 9.1.6 String与其他结构的转换
##### 与基本数据类型、包装类之间的转换
````
@Test
public void test1(){
    String str1 = "123";
    //int num = (int)str1;  //错误
    int num = Integer.parseInt(str1);
    
    String str2 = String.valueOf(num);  //"123"
    String str3 = num + "";
    System.out.println(str1 == str3);
}
````
##### 与字符数组之间的转换
````
@Test
public void test2(){
    String str1 = "abc123";     //题目：a21cb3
    char[] charArray = str1.toCharArray();
    for(int i = 0; i < charArray.length; i++){
        System.out.println(cahrArray[i]);
    }
    
    char[] arr = new char[]{'h', 'e', 'l', 'l', 'o'};
    String str2 = new String(arr);
    System.out.println(str2);
}
````
##### 与字节数组之间的转换
编码：String ---> byte[]: 调用String的getBytes()  
解码：byte[] ---> String: 调用String的构造器  

编码：字符串 ---> 字节 (看得懂--->看不懂的二进制数据)  
解码：编码的逆过程，字节 ---> 字符串 (看不懂的二进制数据 ---> 看得懂)  

说明：解码时，要求家么使用的字符集必须与编码时使用的字符集一直，否则会出现乱码  
````
@Test
public void test3() throws UnsupportedEncodingException{
    String str1 = "abc123"; //使用默认的字符集进行编码。
    byte[] bytes = str1.getBytes(); 
    
    byte[] gbks = str1.getBytes("gbk"); //使用GBK字符集进行编码
    System.out.println(Arrays.toString(gbks));
    
    String str2 = new String(bytes);    //使用默认的字符集进行解码
    System.out.println(str2)
    
    String str3 = new String(gbks);
    System.out.println(str3);   //出现乱码。原因：编码集和解码集不一致
    
    String str4 = new String(gbks, "gbk");
    System.out.println(str4);   //没有出现乱码，此时编码集与解码集一致
}
````

##### StringBuffer和StringBuilder之间的转换
String ---> StringBuffer、StringBuilder：调用StringBuffer、StringBuilder的构造器  
StringBuffer、StringBuilder ---> String：调用String的构造器；StringBuffer、StringBuilder的toString()  

#### JVM中字符串常量池的存放位置说明
JDK1.6：字符串常量池存储在方法区(永久区)  
JDK1.7：字符串常量池存放在堆空间  
JDK1.8：字符串常量池存储在方法区(元空间)  

#### 算法题目
1. 模拟一个trim方法，去除字符串两端的空格。  

2. 将一个字符串进行反转。将字符串中指定部分进行反转。比如将“abcdefg”反转为”abfedcg”  

3. 获取一个字符串在另一个字符串中出现的次数。  
  比如：获取“ab”在 “cdabkkcadkabkebfkabkskab”中出现的次数  

4. 获取两个字符串中最大相同子串。比如： str1 = "abcwerthelloyuiodef“;str2 = "cvhellobnm"//10   
提示：将短的那个串进行长度依次递减的子串与较长的串比较。  

5. 对字符串中字符进行自然顺序排序。"abcwerthelloyuiodef"  
提示：  
+ 字符串变成字符数组。
+ 对数组排序，选择，冒泡，Arrays.sort(str.toCharArray());
+ 将排序后的数组变成字符串。

### 9.2 StringBuffer、StringBuilder
#### 9.2.1 String、StringBuffer、StringBuilder的区别
+ String：不可变的字符序列；底层使用char[ ]存储；  
+ StringBuffer：可变的字符序列；线程安全，但效率低；底层使用char[ ]存储  
+ StringBuilder：可变的字符序列；JDK5.0新增。线程不安全，效率高；底层使用char[ ]存储  

#### 9.2.2 StringBuffer与StringBuilder的内存解析
以StringBuffer为例：  
源码分析：  
````
//正常情况下新建字符串
String str = new String(); //new char[0];
String str1 = new String("abc");    //new char[]{'a', 'b', 'c'};

StringBuffer sb1 = new StringBuffer();  //new char[16]; 相当于底层创建了一个长度为16的数组
System.out.println(sb.length());    
sb1.append('a');    //value[0] = 'a';
sb1.append('b');    //value[1] = 'b';

StringBuffer sb2 = new StringBuffer("abc"); //char[] value = new char["abc".length() + 16];

//问题一：System.out.println(sb2.length()); //3
//问题二：扩容问题：如果需要添加的数据在底层容量不足，就需要对底层数组进行扩容。
//       默认情况下，扩容为原来的2倍+2，同时将原数组的元素复制到新数组中。
        
//       指导意义：开发中建议使用：StringBuffer(int capacity)或StringBuilder(int capacity)
````
#### 9.2.3 对比String、StringBuffer、StringBuilder三者的执行效率
从高到低：StringBuilder > StringBuffer > String
#### 9.2.4 StringBuffer、StringBuilder中的常用方法
+ 增；append(xxx)
+ 删：delete(int start,int end)
+ 改：setCharAt(int n, char ch) / replace(int start, int end, String str)
+ 查：CharAt(int n)
+ 插：insert(int offset, xxx)
+ 长度：length()
+ 遍历：for() + charAt() / toString

### 9.3 JDK8之前日期时间API
#### 9.3.1 获取系统当前时间
````
        long time = System.currentTimeMillis();
        //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差
        //称为时间戳
````
#### 9.3.2 java.uitl.Date类和java.sql.Date类
````
            /*
        java.util.Date类
            |----java.sql.Date类

        1. 两个构造器的使用

        2. 两个方法的使用
            > toString()：显式当前的年月日时分秒时区
            > getTime()：获取当前Date对象对应的毫秒数(时间戳)

        3. java.sql.Date对应着数据库中的日期类型的变量
            > 如何实例化
            > 如何将java.util.Date对象转换为java.sql.Date对象

         */
    @Test
    public void test2(){
        //构造器一：Date()：创建一个对应当前时间的Date对象
        Date date1 = new Date();
        System.out.println(date1.toString());   //Sun Feb 07 15:12:03 CST 2021
        System.out.println(date1.getTime());    //1612682021410

        //构造器二：创建指定毫秒数的Date对象
        Date date2 = new Date(1612682021410L);
        System.out.println(date2.toString());

        //创建java.sql.Date对象
        java.sql.Date date3 = new java.sql.Date(54856453355453L);
        System.out.println(date3.toString());

        //如何将java.util.Date对象转换为java.sql.Date对象
        //情况一
        //Date date4 = new java.sql.Date(456476854534354L);
        //java.sql.Date date = (java.sql.Date) date4;
        //情况二
        Date date6 = new Date();
        java.sql.Date date7 = new java.sql.Date(date6.getTime());   //通过相同的毫秒数将java.util.Date对象转换为java.sql.Date对象
        System.out.println(date7);
    }
````
#### 9.3.3 java.text.SimpleDateFormat类
SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析
##### 1. 两个操作：  
##### 1.1 格式化： 日期---> 字符串  
##### 1.2 解析： 格式化的逆过程，字符串 ---> 日期  
##### 2. SimpleDateFormat的实例化：new+构造器
````
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日 hh:mm");  //以指定方式格式化
        String s1 = simpleDateFormat.format(date);
        System.out.println(s1);

        //字符串必须为符合SimpleDateFormat识别的格式(通过构造器参数体现)，否则会抛异常
        Date parse1 = simpleDateFormat.parse("2000年09月05日 23:59");
        System.out.println(parse1);
    }
````

##### 3. 练习
````
   @Test
    //字符串"2021-02-28"转换为java.sql.Date
    public void test2() throws ParseException {
        Date date = new Date();
        SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat("yyyy-MM-dd");
        Date parse2 = simpleDateFormat1.parse("2021-02-28");
        java.sql.Date date1 = new java.sql.Date(parse2.getTime());
        System.out.println(date1);
        System.out.println(date1.getClass());
    }

    @Test
    //"三天打鱼两天晒网"   从2005-01-01开始，问在xxxx年xx月xx日时是在打鱼还是晒网
    //举例： 2021-01-31
    public void test3() throws ParseException {
        Date date = new Date();

        SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat("yyyy-MM-dd");
        Date parse1 = simpleDateFormat1.parse("2005-01-01");
        Date parse2 = simpleDateFormat1.parse("2020-01-31");
        long l = parse2.getTime() - parse1.getTime();

        long l1 = (l / ((1000 * 60 * 60 * 24) + 1) % 5 );
        if (l1 == 3 || l1 ==2 || l1 ==1){
            System.out.println("正在打鱼");
        }else {
            System.out.println("正在晒网");
        }
    }
````
#### 9.3.4. Calendar类：日历类(抽象类)
##### 具体操作
````
        //1.实例化
        //方式一：创建子类(GregorianCalendar)的对象
        //方式二：调用其静态方法(getInstance())
        Calendar calendar = Calendar.getInstance();

        //2.常用方法
        //get()
        int days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days);

        //set()：将日期强制设置
        calendar.set(Calendar.DAY_OF_MONTH, 4);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days);

        //add()
        calendar.add(Calendar.DAY_OF_MONTH, 15);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days);

        //getTime()：Calendar ---> Date
        Date date = calendar.getTime();
        System.out.println(date);

        //setTime()：Date ---> Calendar
        Date date1 = new Date();
        calendar.setTime(date1);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days);
````
### 9.4 JDK8中新的日期时间API
#### 9.4.1 日期时间API的迭代
第一代：JDK1.0  Date类  
第二代：JDK1.1  Calendar类   一定程度上替换Date类  
第三代：JDK1.8  由Joda-Time包提出一套新的API

#### 9.4.2 前两代存在的问题举例
+ 可变性：像日期和时间这样的类应该是不可变的。
+ 偏移性：Date中的年份是从1900开始的，而月份都从0开始。
+ 格式化：格式化只对Date有用，Calendar则不行。
+ 此外，它们也不是线程安全的；不能处理闰秒等。

#### 9.4.3 java8中新的日期时间API涉及到的包
+ java.time – 包含值对象的基础包
+ java.time.chrono – 提供对不同的日历系统的访问
+ java.time.format – 格式化和解析时间和日期
+ java.time.temporal – 包括底层框架和扩展特性
+ java.time.zone – 包含时区支持的类

#### 9.4.4 本地日期、本地时间、本地日期时间的使用：LocalDate/LocalTime/LocalDateTime
##### 说明：
LocalDate、LocalTime、LocalDateTime类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。 它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区 相关的信息。  
##### 常用方法
+ now( ) / * now(ZoneId zone) 静态方法，根据当前时间创建对象/指定时区的对象  
+ of( ) 静态方法，根据指定日期/时间创建对象  
+ getDayOfMonth( )/getDayOfYear( ) 获得月份天数(1-31) /获得年份天数(1-366)  
+ getDayOfWeek( ) 获得星期几(返回一个 DayOfWeek 枚举值)  
+ getMonth( ) 获得月份, 返回一个 Month 枚举值  
+ getMonthValue( ) / getYear( ) 获得月份(1-12) /获得年份  
+ getHour( )/getMinute()/getSecond( ) 获得当前对象对应的小时、分钟、秒  
+ withDayOfMonth( )/withDayOfYear( )/  
+ withMonth( )/withYear( ) 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象  
+ plusDays( ), plusWeeks( ),  
+ plusMonths( ), plusYears( ),plusHours( ) 向当前对象添加几天、几周、几个月、几年、几小时  
+ minusMonths( ) / minusWeeks()/  
+ minusDays( )/minusYears( )/minusHours( ) 从当前对象减去几月、几周、几天、几年、几小时  

#### 9.4.5 瞬时点
##### 说明
1. 时间线上的一个瞬时点。 
2. 表示自1970年1月1日0时0分0秒（UTC）开始的秒数
3. 类似于java.util类
##### 常用方法
+ now( ) 静态方法，返回默认UTC时区的Instant类的对象
+ ofEpochMilli(long epochMilli) 静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒 数之后的Instant类的对象
+ atOffset(ZoneOffset offset) 结合即时的偏移来创建一个OffsetDateTime
+ toEpochMilli( ) 返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳
  
*时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。*

#### 9.4.6 日期时间格式化类：DateTimeFormatter
##### 说明
1. DateTimeFormatter:格式化或解析日期、时间。
2. 类似于SimpleDateFormat
##### 常用方法
实例化方式：  
+ 预定义的标准格式。如： ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME  
+ 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)  
+ 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)  

常用方法：  
+ ofPattern(String pattern) 静态方法，返回一个指定字符串格式的DateTimeFormatter
+ format(TemporalAccessor t) 格式化一个日期、时间，返回字符串 
+ parse(CharSequence text) 将指定格式的字符序列解析为一个日期、时间
**特别地，自定义的格式。如ofPattern("yyyy-MM-dd hh:mm:ss")**
````
        DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("yyyy年MM月dd日  hh:mm:ss");
        System.out.println(timeFormatter);
        //格式化
        String s = timeFormatter.format(time);
        System.out.println(s);

        System.out.println("***********************************************");

        //解析
        TemporalAccessor parse1 = timeFormatter.parse("2021年02月08日  03:35:26");
        System.out.println(parse1);
````
#### 9.4.7 其他API的使用
##### 带时区日期时间：ZoneDateTime/ZoneId
举例：  
+ ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris
+ ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。
    + 其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如： Asia/Shanghai等
+ Clock：使用时区提供对当前即时、日期和时间的访问的时钟。
+ 持续时间：Duration，用于计算两个“时间”间隔
+ 日期间隔：Period，用于计算两个“日期”间隔
+ TemporalAdjuster: 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。
+ TemporalAdjusters: 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。
````
//ZoneId:类中包含了所有的时区信息
    // ZoneId的getAvailableZoneIds():获取所有的ZoneId
    Set<String> zoneIds = ZoneId.getAvailableZoneIds();
    for (String s : zoneIds) {
        System.out.println(s);
    }
    // ZoneId的of():获取指定时区的时间
    LocalDateTime localDateTime = LocalDateTime.now(ZoneId.of("Asia/Tokyo"));
    System.out.println(localDateTime);
    
    //ZonedDateTime:带时区的日期时间
    // ZonedDateTime的now():获取本时区的ZonedDateTime对象
    ZonedDateTime zonedDateTime = ZonedDateTime.now();
    System.out.println(zonedDateTime);
    // ZonedDateTime的now(ZoneId id):获取指定时区的ZonedDateTime对象
    ZonedDateTime zonedDateTime1 = ZonedDateTime.now(ZoneId.of("Asia/Tokyo"));
    System.out.println(zonedDateTime1);
    
    //Duration:用于计算两个“时间”间隔，以秒和纳秒为基准
    LocalTime localTime = LocalTime.now();
    LocalTime localTime1 = LocalTime.of(15, 23, 32);
    //between():静态方法，返回Duration对象，表示两个时间的间隔
    Duration duration = Duration.between(localTime1, localTime);
    System.out.println(duration);
    
    System.out.println(duration.getSeconds());
    System.out.println(duration.getNano());
    
    LocalDateTime localDateTime = LocalDateTime.of(2016, 6, 12, 15, 23, 32);
    LocalDateTime localDateTime1 = LocalDateTime.of(2017, 6, 12, 15, 23, 32);
    
    Duration duration1 = Duration.between(localDateTime1, localDateTime);
    System.out.println(duration1.toDays());
    
    //Period:用于计算两个“日期”间隔，以年、月、日衡量
    LocalDate localDate = LocalDate.now();
    LocalDate localDate1 = LocalDate.of(2028, 3, 18);
    Period period = Period.between(localDate, localDate1);
    System.out.println(period);
    System.out.println(period.getYears());
    System.out.println(period.getMonths());
    System.out.println(period.getDays());
    Period period1 = period.withYears(2);
    System.out.println(period1);
    
    // TemporalAdjuster:时间校正器
    // 获取当前日期的下一个周日是哪天？
    TemporalAdjuster temporalAdjuster = TemporalAdjusters.next(DayOfWeek.SUNDAY);
    LocalDateTime localDateTime = LocalDateTime.now().with(temporalAdjuster);
    System.out.println(localDateTime);
    // 获取下一个工作日是哪天？
    LocalDate localDate = LocalDate.now().with(new TemporalAdjuster() {
        @Override
        public Temporal adjustInto(Temporal temporal) {
            LocalDate date = (LocalDate) temporal;
            if (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) {
                return date.plusDays(3);
            } else if (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) {
                return date.plusDays(2);
            } else {
                return date.plusDays(1);
            }   
        }
    });
    System.out.println("下一个工作日是：" + localDate);
````

##### 与传统日期处理的转换
|类|To遗留类|From遗留类|
|:---:|:---:|:---:|
|java.time.Instant与java.util.Date|Date.from(instant)|date.toInstant()|
|java.time.Instant与java.sql.Timestamp|Timestamp.from(instant)|timestamp.toInstant()|
|java.time.ZonedDateTime与java.util.GregorianCalendar|GregorianCalendar.from(zonedDateTime)|cal.toZonedDateTime()|
java.time.LocalDate与java.sql.Time|e Date.valueOf(localDate)|date.toLocalDate()|
|java.time.LocalTime与java.sql.Time|Date.valueOf(localDate)|date.toLocalTime()|
|java.time.LocalDateTime与java.sql.Timestamp|Timestamp.valueOf(localDateTime)|timestamp.toLocalDateTime()|
|java.time.ZoneId与java.util.TimeZone|Timezone.getTimeZone(id)|timeZone.toZoneId()|
|java.time.format.DateTimeFormatter与java.text.DateFormat|formatter.toFormat()|无|

### 9.5 Java比较器
#### 9.5.1 使用背景
说明：Java中的对象，正常情况下只能比较：== 或 !=  不能使用 > 或 < 。但是在开发场景中，我们需要对多个对象进行排序，言外之意，需要比较对象的大小。如何实现？使用两个接口中的任意一个：Compare或Comparator。  
#### 9.5.2 自然排序：使用Comparable接口
##### 说明
1. 像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式  
2. 像String、包装类重写ComparableTo()方法之后，进行了小到大的排列  
3. 重写CompareTo(obj)的规则:  
+ 如果当前对象this大于形参对象obj，则返回正整数，  
+ 如果当前对象this小于形参对象obj，则返回负整数，  
+ 如果i当前对象this等于形参对象obj，则返回零。  
4. 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo()方法在compareTo(obj)方法中指明排序方式  
##### 自定义代码举例
````
 @Override
    public String toString() {
        return "Goods{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }

    //指明商品比较大小的方式:价格从高到低排序，如果两个价格相同，则按名声顺序排列
    @Override
    public int compareTo (Object o) {
        if (o instanceof Goods) {
            Goods goods = (Goods) o;
            if (this.price > goods.price) {
                return 1;
            } else if (this.price < goods.price) {
                return -1;
            }else {
//                return 0;
                return this.name.compareTo(goods.name);
            }
        }
        throw new RuntimeException("传入数据类型不一致" );
    }
````
#### 9.5.3 定制排序
##### 说明
1. 背景：当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序，  
2. 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。  
#### 代码举例
````
        Comparator comparator = new Comparator() {
            //指明产品比较大小的方式：按照产品名称从低到高排序，再按照价格从高到低排序
            @Override
            public int compare(Object o1, Object o2) {
                if (o1 instanceof Goods && o2 instanceof Goods) {
                    Goods g1 = (Goods) o1;
                    Goods g2 = (Goods) o2;
                    if (g1.getName().equals(g2.getName())) {
                                return Double.compare(g1.getPrice(), g2.getPrice());
                    } else {
                        return g1.getName().compareTo(g2.getName());
                    }
                }
                throw new RuntimeException("传入数据类型不一致" );
            }
        }
````

#### 9.5.4 两种方式的对比
* Comparable接口的方式一旦确定，保证Comparable接口实现类的对象在任何位置都可以比较大小
* Comparator接口属于临时性的比较

### 9.6 其他类
#### 9.6.1 System类
+ System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。  
+ 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。  
+ 方法
    +  native long currentTimeMillis()：
    + void exit(int status)：
    + void gc()：
    + String getProperty(String key)：
    
````
    String javaVersion = System.getProperty("java.version");
    System.out.println("java的version:" + javaVersion);
    
    String javaHome = System.getProperty("java.home");
    System.out.println("java的home:" + javaHome);
    
    String osName = System.getProperty("os.name");
    System.out.println("os的name:" + osName);
    
    String osVersion = System.getProperty("os.version");
    System.out.println("os的version:" + osVersion);
    
    String userName = System.getProperty("user.name");
    System.out.println("user的name:" + userName);
    
    String userHome = System.getProperty("user.home");
    System.out.println("user的home:" + userHome);
    
    String userDir = System.getProperty("user.dir");
    System.out.println("user的dir:" + userDir);
````
#### 9.6.5 Math类
java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。

#### 9.6.6 BigInteger、BigDecimal
##### 说明
+ java.math包的BigInteger可以表示不可变的任意精度的整数。
+ 在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。

##### 代码举例
````
public void testBigInteger() {
    BigInteger bi = new BigInteger("12433241123");
    BigDecimal bd = new BigDecimal("12435.351");
    BigDecimal bd2 = new BigDecimal("11");
    System.out.println(bi);
    // System.out.println(bd.divide(bd2));
    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));
    System.out.println(bd.divide(bd2, 15, BigDecimal.ROUND_HALF_UP));
}
````

## 10. 枚举类和注解
### 10.1.1 枚举类的使用
#### n枚举类说明
1. 枚举类的理解：类的对象只有有限个，确定个，我们称此类为枚举类  
2. 当需要定义一组常量时，强烈建议使用枚举类  
3. 如果枚举类中只有一个对象，则可以作为单例模式的实现方式  
#### 10.1.2 如何自定义枚举类？步骤
````
class Season{

    //1.声明Season对象的属性: private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //2. 私有化类的构造器
    private Season(String seasonName, String seasonDesc){
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }

    //3. 提供当前枚举类的多个对象
    public static final Season SPRING = new Season("春天", "温暖");
    public static final Season SUMMER = new Season("夏天", "炎热");
    public static final Season AUTUMN = new Season("秋天", "凉爽");
    public static final Season WINTER = new Season("冬天", "寒冷");

    //其他诉求1：获取枚举类对象的属性
    public String getSeasonName(){
        return seasonName;
    }

    public String getSeasonDesc(){
        return seasonDesc;
    }

    //其他诉求2：提供toString()
    @Override
    public String toString() {
        return "Season{" +
                "seasonName='" + seasonName + '\'' +
                ", seasonDesc='" + seasonDesc + '\'' +
                '}';
    }
}
````
#### 10.1.3 JDK5.0新增使用enum定义枚举类。步骤：
````
public class EnumTest1 {
    public static void main(String[] args) {
        Season1 summer = Season1.SUMMER;
        System.out.println(Season1.class.getSuperclass());
        System.out.println("----------------------------------");
        Season1[] values = Season1.values();
        for (int i = 0; i < values.length; i++) {
            System.out.println(values[i]);
        }
        System.out.println("----------------------------------");
        Thread.State[] values1 = Thread.State.values();
        for (int i = 0; i < values1.length; i++) {
            System.out.println(values1[i]);
        }
        System.out.println("----------------------------------");
        //valueOf(String objName): 根据提供的objName，返回与objName同名的枚举类对象
        //如果未找到名为objName的对象，则抛异常：IllegalArgumentException
        Season1 winter = Season1.valueOf("WINTER");
        System.out.println(winter);
        System.out.println("----------------------------------");
        //调用接口
        winter.test();
    }
}

enum Season1{

    //1. 提供当前枚举类的多个对象，多个对象之间用","隔开，末尾对象用";"结束
    SPRING("春天", "温暖"),
    SUMMER("夏天", "炎热"),
    AUTUMN("秋天", "凉爽"),
    WINTER("冬天", "寒冷");

    //2.声明Season对象的属性: private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //3. 私有化类的构造器
    private Season1(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }

    //其他诉求1：获取枚举类对象的属性
    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }
}

````
#### 10.1.4 使用enum定义枚举类之后，枚举类常用方法：(继承于java.lang.Enum类)
````
        Season1 summer = Season1.SUMMER;
        System.out.println(Season1.class.getSuperclass());
        //toString(): 返回枚举类对象的名称
        System.out.println(summer.toString());
        System.out.println("----------------------------------");
        //values(): 返回所有枚举类对象构成的数组
        Season1[] values = Season1.values();
        for (int i = 0; i < values.length; i++) {
            System.out.println(values[i]);
        }
        System.out.println("----------------------------------");
        Thread.State[] values1 = Thread.State.values();
        for (int i = 0; i < values1.length; i++) {
            System.out.println(values1[i]);
        }
        System.out.println("----------------------------------");
        //valueOf(String objName): 根据提供的objName，返回与objName同名的枚举类对象
        //如果未找到名为objName的对象，则抛异常：IllegalArgumentException
        Season1 winter = Season1.valueOf("WINTER");
        System.out.println(winter);
        System.out.println("----------------------------------");
        //调用接口
````
#### 10.1.5 使用enum定义枚举类之后，如何让枚举类对象分别实现接口
````
interface Test{
    void test();
}

enum Season1 implements Test{

    SPRING("春天", "温暖"){
        @Override
        public void test() {
            System.out.println("这是一个测试，春天");
        }
    },
    SUMMER("夏天", "炎热"){
        @Override
        public void test() {
            System.out.println("这是一个测试，夏天");
        }
    },
    AUTUMN("秋天", "凉爽"){
        @Override
        public void test() {
            System.out.println("这是一个测试，秋天");
        }
    },
    WINTER("冬天", "寒冷"){
        @Override
        public void test() {
            System.out.println("这是一个测试，冬天");
        }
    };
````

### 10.2 注解的使用
#### 10.2.1 注解的理解
1. 理解注解：  
1.1 jdk5.0新增功能  
1.2 Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。  
1.3 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。   

**框架 = 注解 + 反射机制 + 设计模式**

#### 10.2.2 注解的使用示例
+ 示例一：生成文档的相关注解
+ 示例二：在编译时进行格式检查(JDK内置的三个基本注解)
    + @Override: 限定重写父类方法，该注解只能用于方法
    + @Deprecated: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择
    + @SuppressWarnings: 抑制编译器警告
+ 示例三：跟踪代码依赖性，实现配置文件功能
#### 10.2.3 如何自定义注解：参照@SuppressWarnings定义
##### 说明
*  如果注解有成员，在使用注解时，需要指明成员的值(参照MyAnnotation构造)  
*  自定义注解必须配上注解的信息处理流程(使用反射)才有意义  
*  自定义注解通常都会指明两个元注解：Retention、Target  
##### 代码举例
````
@Inherited
@Repeatable(MyAnnotations.class)
@Retention(RetentionPolicy.RUNTIME)
Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER, TYPE_USE})
public @interface MyAnnotation {
    String value() default "hello";
}
//注解声明为@interface，此interface和接口没有关系。
//内部定义成员，通常使用从value表示
//可以指定成员的默认值，使用default定义
//如果自定义注解没有成员，表明是一个标识作用
````
#### 10.2.4 元注解：对现有的注解进行解释说明的注解
JDK提供的四种元注解：对现有的注解进行解释说明的注解  
* Retention: 指定的所修饰的Annotation的生命周期：SOURCE、CLASS(默认行为)、RUNTIME(只有声明为RUNTIME生命周期的注解才能通过反射获取)  
* Target: 用于指定被修饰的Annotation能用于修饰哪些程序元素  
//以下两种元注解出现频率较低  
* Documented: 表示所修饰的注解被javadoc解析时，保留下来
* Inherited: 被它修饰的Annotation将具有继承性

#### 10.2.5 如何获取注解信息：通过反射来进行获取、调用
前提：要求此元注解的Retention中声明的生命周期状态为RUNTIME  

#### 10.2.6 JDK8中注解的新特性
* 可重复注解：在MyAnnotation声明@Repetable，成员值为MyAnnotations.class
    * MyAnnotation的Target和Retention等元注解和MyAnnotations相同
* 类型注解：ElementType.TYPE_PARAMETER表示该注解能写在类型变量的声明语句中(如泛型声明)
    * ElementType.TYPE_USE表示该注解能写在适用类型的任何语句中。

## 11. Java集合
### 11.1 数组与集合
#### 11.1.1 集合与数组储存数据概述
集合、数组都是对多个数据进行存储操作的结构，简称Java容器。  
说明：此时的存储，主要指内存层面的存储，不涉及持久化的存储(.txt, .jpg, .avi, 数据库中)  
#### 11.1.2 数组储存的特点
* 一旦初始化以后，长度确定了  
* 数组一旦定义好，其元素的类型就确定了。我们也就只能操作指定类型的数据了。  
#### 11.1.3 数组储存的弊端
* 一旦初始化以后，其长度不可修改。
* 数组中提供的方法非常有限，对于添加、删除、插入数据等操作非常不方便。同时效率不高
* 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用
* 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求不能够满足。
#### 11.1.4 集合储存的优点
解决数组存储数据方面的弊端。
### 11.2 Collection接口
#### 11.2.1 单列集合框架结构
      |----Collection接口：单列集合，用来储存一个一个的对象  
          |----List接口：有序的、可重复的数据  ---- "动态数组"  
              |----ArrayList、LinkedList、Vector  

          |----Set接口：无序的、不可重复的数据  ---- 类似于数学意义的"集合"  
              |----HashSet、LinedHashSet、TreeSet  
#### 11.2.2 图示
![Collection接口继承树](https://raw.githubusercontent.com/Carln-66/img/main/1612888096(1).png) 








